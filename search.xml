<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CentOS搭建Apache服务器和ftp服务器</title>
      <link href="/desirelife6.github.io/2019/11/13/%E5%9C%A8CentOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"/>
      <url>/desirelife6.github.io/2019/11/13/%E5%9C%A8CentOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="CentOS搭建Apache服务器和ftp服务器"><a href="#CentOS搭建Apache服务器和ftp服务器" class="headerlink" title="CentOS搭建Apache服务器和ftp服务器"></a>CentOS搭建Apache服务器和ftp服务器</h2><p>[TOC]</p><h3 id="1-Apache安装"><a href="#1-Apache安装" class="headerlink" title="1. Apache安装"></a>1. Apache安装</h3><p>使用<strong><code>su root</code></strong>得到权限后使用<strong><code>yum install httpd</code></strong>安装Apache服务器</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573479969811.png" alt="1573479969811"></p><p>使用<strong><code>rpm -qa | grep httpd</code></strong>进行验证，可见已经安装完成</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573480086501.png" alt="1573480086501"></p><h3 id="2-检验网络的连通性"><a href="#2-检验网络的连通性" class="headerlink" title="2. 检验网络的连通性"></a>2. 检验网络的连通性</h3><p>由下图可知网络连通性良好</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573480277479.png" alt="1573480277479"></p><h3 id="3-启动apache服务器，然后用客户机端访问默认界面和个人界面"><a href="#3-启动apache服务器，然后用客户机端访问默认界面和个人界面" class="headerlink" title="3. 启动apache服务器，然后用客户机端访问默认界面和个人界面"></a>3. 启动apache服务器，然后用客户机端访问默认界面和个人界面</h3><h4 id="3-1-启动apache服务，访问默认界面"><a href="#3-1-启动apache服务，访问默认界面" class="headerlink" title="3.1 启动apache服务，访问默认界面"></a>3.1 启动apache服务，访问默认界面</h4><p>使用<strong><code>systemctl start httpd</code></strong>启动apache服务并使用<strong><code>systemctl stop firewalld</code></strong>关闭防火墙</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573481373755.png" alt="1573481373755"></p><p>使用浏览器访问，访问正常</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573481511844.png" alt="1573481511844"></p><p>进入<strong><code>var/www/html</code></strong>文件夹下新建<strong><code>index.html</code></strong>，修改默认主页后再次访问</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573481942864.png" alt="1573481942864"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573482110924.png" alt="1573482110924"></p><h4 id="3-2-创建用户个人界面"><a href="#3-2-创建用户个人界面" class="headerlink" title="3.2 创建用户个人界面"></a>3.2 创建用户个人界面</h4><p>在用户<strong><code>desirelife</code></strong>目录下新建<strong><code>public_html</code></strong>目录，并修改其权限</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573482843667.png" alt="1573482843667"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573482820136.png" alt="1573482820136"></p><p>写入个人主页的<strong><code>index.html</code></strong>，内容为一行字： “This is Desirelife’s web”</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573482995271.png" alt="1573482995271"></p><p>得到root权限并修改<strong><code>/etc/httpd/conf.d/userdir</code></strong>文件，允许用户架设个人web站点。<img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573483295796.png" alt="1573483295796"></p><p>SELLinux模式有时会阻碍客户机的访问，因此我们使用setenforce命令把SELLinux设置为允许模式，getenforce命令查看设置后的SELLinux模式。</p><p>然后重启服务，在客户机端进行访问。</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573483733357.png" alt="1573483733357"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573485971048.png" alt="1573485971048"></p><h3 id="4-配置虚拟主机"><a href="#4-配置虚拟主机" class="headerlink" title="4. 配置虚拟主机"></a>4. 配置虚拟主机</h3><ul><li><p>分别给网卡配置两个ip地址23.17.235和172.23.17.233（这里的IP地址需要和虚拟机上的IP地址网段保持一致）</p><p>虚拟机上的ip地址如图1所示，为<strong>192.168.159.128</strong></p></li></ul><ul><li><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494006717.png" alt="1573494006717"></p></li><li><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494129207.png" alt="1573494129207"></p></li><li></li><li><p>分别创建<strong><code>“/var/www/ip4”</code></strong>和<strong><code>“/var/www/ip5”</code></strong>两个主目录和默认首页文件。</p></li></ul><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494427165.png" alt="1573494427165"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573493023937.png" alt="1573493023937"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573493180927.png" alt="1573493180927"><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573493190258.png" alt="1573493190258"></p><ul><li>在<strong><code>/etc/httpd/conf/httpd.conf</code></strong>文件中，设置基于IP地址的虚拟主机，配置内容如下</li></ul><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494250617.png" alt="1573494250617"></p><ul><li><p>重启服务后再在客户端访问，可在客户端输入<strong><code>http://IP</code></strong>形式的URL地址访问虚拟主机，则可以访问对应的虚拟主机。</p><p> <img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494471077.png" alt="1573494471077"><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573494485530.png" alt="1573494485530"></p></li></ul><h3 id="5-vsftpd的安装和配置"><a href="#5-vsftpd的安装和配置" class="headerlink" title="5. vsftpd的安装和配置"></a>5. vsftpd的安装和配置</h3><h4 id="5-1-安装ftp服务"><a href="#5-1-安装ftp服务" class="headerlink" title="5.1 安装ftp服务"></a>5.1 安装ftp服务</h4><p>使用yum软件管理包安装ftp服务</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573631747689.png" alt="1573631747689"></p><p>查询已安装的软件过滤出vsftpd，可知安装成功</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573631823142.png" alt="1573631823142"></p><h4 id="5-2-启动ftp服务"><a href="#5-2-启动ftp服务" class="headerlink" title="5.2 启动ftp服务"></a>5.2 启动ftp服务</h4><p>启动以后直接用localhost登录，发现与服务器的连接断开，如图所示</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573632827812.png" alt="1573632827812"></p><p>这是因为VSFTPD是一个FTP服务器程序，SELinux是CentOS的防火墙组件， vsftpd 默认被 SELinux 拦截。可以通过在linux中设置ftp允许访问解决这个问题。如图所示，将<strong><code>ftpd_full_access</code></strong>设置为<strong><code>on</code></strong></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573632931871.png" alt="1573632931871"></p><p>配置文件允许匿名访问等</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573632462704.png" alt="1573632462704"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573632515004.png" alt="1573632515004"></p><p>启动服务，此时可以通过ip地址访问服务器，查询ftp服务的状态，可见已经处于<strong><code>active</code></strong>状态</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573632661999.png" alt="1573632661999"></p><p>查询21端口</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573631868316.png" alt="1573631868316"></p><p>在本地使用<strong>anonymous</strong>匿名登陆进行验证，保证返回220表示服务正常，230表示登陆成功</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634183901.png" alt="1573634183901"></p><p>使用客户机，用<strong>ip</strong>进行访问，可以看到系统预设的pub文件夹，表示访问正常</p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634258672.png" alt="1573634258672"></p><h4 id="5-3-创建ftp用户"><a href="#5-3-创建ftp用户" class="headerlink" title="5.3 创建ftp用户"></a>5.3 创建ftp用户</h4><ul><li>在centos添加用户<strong>ftpuser</strong>，并设置密码（这里由于密码设置过于简单被迫设置了好几次XD），限制该用户的登陆</li></ul><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634470056.png" alt="1573634470056"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634548706.png" alt="1573634548706"></p><ul><li>创建用户目录并指定特定用户的登陆目录</li></ul><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634839914.png" alt="1573634839914"></p><p><img src="C:%5CUsers%5CDesirelife%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5C1573634877559.png" alt="1573634877559"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -Computer Networking </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易微信开发白皮书</title>
      <link href="/desirelife6.github.io/2019/11/03/%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
      <url>/desirelife6.github.io/2019/11/03/%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="简易微信开发白皮书"><a href="#简易微信开发白皮书" class="headerlink" title="简易微信开发白皮书"></a>简易微信开发白皮书</h1><p>[TOC]</p><h2 id="1-软件概况展示"><a href="#1-软件概况展示" class="headerlink" title="1. 软件概况展示"></a>1. 软件概况展示</h2><h3 id="1-1-功能展示（截图附于文末）"><a href="#1-1-功能展示（截图附于文末）" class="headerlink" title="1.1 功能展示（截图附于文末）"></a>1.1 功能展示（截图附于文末）</h3><ul><li><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4></li></ul><p>1） 注册、登陆、登出(包含是否已注册、重名判断等)</p><p>2） 添加、删除好友</p><p>3） 好友列表展示</p><p>4） 实时的新消息提醒和收发消息（包含对是否好友，好友在线状态的判断）</p><p>5） 支持对文件，图片的发送和接收</p><ul><li><h4 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h4></li></ul><p>6） <strong>保存聊天记录</strong></p><p>7） <strong>实时弹窗提醒</strong>用户收到新消息，并<strong>展示发送方和消息预览</strong></p><p>8） 缓存聊天内容，可以<strong>保存未读的聊天记录</strong></p><p>9） 服务器主动向客户端推送信息（TCP长连接，<strong>模拟实现双工通信</strong>）</p><p>10） 使用<strong><code>token</code>进行用户身份验证</strong>，除密码验证外提供多一层的安全保障</p><p>11） UI美化，<strong>消息气泡大小动态变化</strong></p><p>12） 展示用户信息，如用户名，头像等</p><h3 id="1-2-健壮性及异常情况处理展示"><a href="#1-2-健壮性及异常情况处理展示" class="headerlink" title="1.2 健壮性及异常情况处理展示"></a>1.2 健壮性及异常情况处理展示</h3><p>1） 检测并阻止重复注册或登陆</p><p>2） 检测用户的在线状态</p><p>3） 检查用户的好友列表及好友关系</p><h2 id="2-软件整体系统架构分析"><a href="#2-软件整体系统架构分析" class="headerlink" title="2. 软件整体系统架构分析"></a>2. 软件整体系统架构分析</h2><h3 id="2-1-整体：前后端分离"><a href="#2-1-整体：前后端分离" class="headerlink" title="2.1 整体：前后端分离"></a>2.1 整体：前后端分离</h3><ul><li>简易微信整体<strong>前后端分离</strong></li><li>服务器的开发语言为 java，开发工具为 intelliJ Idea；</li><li>客户端的开发语言为 kotlin， 开发工具为 Android Studio。 </li><li>服务器部署在本机，与各客户端采用socket连接，C/S模式。UML图如下：</li></ul><h3 id="2-2-服务器端：JDBC-Socket-Thread-PostgreSql"><a href="#2-2-服务器端：JDBC-Socket-Thread-PostgreSql" class="headerlink" title="2.2 服务器端：JDBC, Socket, Thread, PostgreSql"></a>2.2 服务器端：JDBC, Socket, Thread, PostgreSql</h3><ul><li>采用<code>JDBC</code>管理底层数据库，底层采用<code>postgreSql</code>数据库存储必要的信息</li><li>使用 java结合sql语句操作数据库，实现对信息的增删查改。</li><li>采用<code>Socket</code>连接实现与客户端的连接与通信，从而成为沟通客户端的中枢，典型的C/S。</li><li>采用多线程开启socket通信，使用统一的Server和Map进行管理</li><li>重写java的Tuple类，以实现服务器的多返回值</li></ul><h3 id="2-3-客户端：MVP、Fragment、Json"><a href="#2-3-客户端：MVP、Fragment、Json" class="headerlink" title="2.3 客户端：MVP、Fragment、Json"></a>2.3 客户端：MVP、Fragment、Json</h3><ul><li>使用 kotlin开发，MVP技术架构。数据层(model)、数据处理层(presenter)、用户交互层(view)高度解耦，使得数据处理和用户交互更加优雅</li><li>主界面采用ViewPager+Fragment，可以轻松在各界面间滑动</li><li>每项操作都提供反馈，实时接收服务器消息</li><li>自定数据、协议格式，借鉴目前常用的Json格式</li><li>快速、稳定的图片传输</li></ul><h2 id="3-自定义协议分析"><a href="#3-自定义协议分析" class="headerlink" title="3. 自定义协议分析"></a>3. 自定义协议分析</h2><h3 id="3-1-传输协议及格式"><a href="#3-1-传输协议及格式" class="headerlink" title="3.1 传输协议及格式"></a>3.1 传输协议及格式</h3><p>简易微信server端采用TCP作为传输层协议，http作为应用层协议，并对http的协议格式和报文格式进行自定义修改，报文采用 json 格式数据文档实现server与client间的通信。</p><h3 id="3-2-网络连接"><a href="#3-2-网络连接" class="headerlink" title="3.2 网络连接"></a>3.2 网络连接</h3><ul><li>服务器搭建在本地，监听12000端口，本机访问服务器使用 ip为127.0.0.1，其余客户端访问服务器时地址采用本机 ip。服务器程序会一直监听发起请求的客户端，与之保持连接状态，直到客户<br>端主动断开连接。在此期间，服务器与客户端间的输入输出流将保持。需要注意的是，每次服务器重启会强制登出所有用户。 </li><li>服务器可以接受并处理post请求，以json格式的数据返回请求结果及信息</li></ul><h3 id="3-3-部分自定义协议的接口文档（完整版太多了，附于文档末尾）"><a href="#3-3-部分自定义协议的接口文档（完整版太多了，附于文档末尾）" class="headerlink" title="3.3 部分自定义协议的接口文档（完整版太多了，附于文档末尾）"></a>3.3 部分自定义协议的接口文档（完整版太多了，附于文档末尾）</h3><h4 id="1-返回报文的body组成"><a href="#1-返回报文的body组成" class="headerlink" title="1. 返回报文的body组成"></a>1. 返回报文的body组成</h4><p>每次服务器返回的报文body都会包含以下信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:code,  “msg”:”msg”,  “type”:”type” &#125;</span><br></pre></td></tr></table></figure><p>其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类</p><h4 id="2-用户注册"><a href="#2-用户注册" class="headerlink" title="2. 用户注册"></a>2. 用户注册</h4><p>接口路径为 <code>ip/register</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回报文的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”register” &#125;</span><br></pre></td></tr></table></figure><p>返回的code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">注册成功</td></tr><tr><td align="center">-1</td><td align="center">重复的用户名</td></tr></tbody></table><h4 id="3-用户登陆"><a href="#3-用户登陆" class="headerlink" title="3. 用户登陆"></a>3. 用户登陆</h4><p>接口路径为<code>ip/login</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”login”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">密码错误</td></tr><tr><td align="center">2</td><td align="center">已经在线了</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr></tbody></table><h4 id="4-用户登出"><a href="#4-用户登出" class="headerlink" title="4. 用户登出"></a>4. 用户登出</h4><p>路径<code>ip/logout</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “userName”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” offline” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">已经离线了</td></tr><tr><td align="center">2</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户不存在</td></tr></tbody></table><h4 id="5-获取好友列表"><a href="#5-获取好友列表" class="headerlink" title="5. 获取好友列表"></a>5. 获取好友列表</h4><p>路径<code>ip/friends</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friends”,  “friends”:[“friend1”,”friend2”] &#125; </span><br><span class="line">-- friends是一个jsonArray的数组</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr></tbody></table><h4 id="6-完整版自定义协议的接口文档附于本文档末尾"><a href="#6-完整版自定义协议的接口文档附于本文档末尾" class="headerlink" title="6. 完整版自定义协议的接口文档附于本文档末尾"></a>6. 完整版自定义协议的接口文档附于本文档末尾</h4><h2 id="3-各部分实现技术细节分析"><a href="#3-各部分实现技术细节分析" class="headerlink" title="3. 各部分实现技术细节分析"></a>3. 各部分实现技术细节分析</h2><h3 id="3-1-服务器技术细节"><a href="#3-1-服务器技术细节" class="headerlink" title="3.1 服务器技术细节"></a>3.1 服务器技术细节</h3><h4 id="3-1-1-DataBeans-包"><a href="#3-1-1-DataBeans-包" class="headerlink" title="3.1.1 DataBeans 包"></a>3.1.1 <strong><code>DataBeans</code></strong> 包</h4><ul><li>该包下存放登录、注册等各种不同请求的数据类，统一命名为<strong><code>XxxRequestBean</code></strong>,<strong><code>XxxResponseBean</code></strong>,如（<code>CommonRequestBean</code>, <code>CommonResponseBean</code>等）</li><li><strong><code>XxxRequestBean</code></strong>用于存储从请求报文中按格式解析出的信息，用于本地对数据库的操作</li><li><strong><code>XxxResponseBean</code></strong>用于存储本地对数据库增删查改后的结果，用于向发起请求的客户端返回信息以及向需要转发的客户端转发消息</li><li>值得一提的是在该包内抽象出了<strong><code>JsonToObject</code></strong>和<strong><code>ObjectToJson</code></strong>两个接口，实现通信报文中json格式数据与服务器中java对象类型数据的项目转化，提高了代码复用性和可读性。</li></ul><h4 id="3-1-2-HttpServer-java"><a href="#3-1-2-HttpServer-java" class="headerlink" title="3.1.2 HttpServer.java"></a>3.1.2 <strong><code>HttpServer.java</code></strong></h4><ul><li>该类持有server服务器的对象，并持有<code>userMap</code>等数据结构保存用户的<code>id</code>和对应的<code>socket</code>通信，从而实现<strong>服务器向特定用户主动推送消息</strong>，实现<strong>好友申请和收到消息的即时提醒</strong></li><li>在此类使用多线程处理每个独立的socket通信，避免相互之间的干扰，便于管理，也能实现多用户登录</li><li>此类中的<strong><code>initDataBase</code></strong>方法使用JDBC连接数据库，若是数据库不存在时则主动建立数据库，具有良好的健壮性</li></ul><h4 id="3-1-3-ServerThread-java"><a href="#3-1-3-ServerThread-java" class="headerlink" title="3.1.3 ServerThread.java"></a>3.1.3 <strong><code>ServerThread.java</code></strong></h4><ul><li>该类定义每个独立的线程中socket通信的动作，其中包括：</li><li><ul><li>重载<strong><code>Thread</code></strong>的<strong><code>run</code></strong>方法<strong>解析自定义的请求报文</strong>，得到请求种类（如<code>GET</code>）和请求的<code>url</code>以及请求报文<code>body</code>，传递给<strong><code>post</code></strong>函数</li><li><strong><code>post</code></strong>函数得到报文，根据<code>header</code>中的url对各个功能函数进行调用，进行相应处理后得到应返回的数据。并通过各<code>Bean</code>类的格式化函数将信息格式化为合法的报文进行返回</li><li>使用<strong><code>response</code>返回发出请求的客户端</strong>，使用<strong><code>sendInfos</code>向被请求的客户端主动推送消息</strong></li><li><code>regist</code>， <code>login</code>等功能函数从报文的<code>body</code>中得到用户名，身份验证<code>token</code>等信息，用于实现简易微信的各项功能，如：</li><li><ul><li><code>registe</code> 从报文中获得用户名和密码，在数据库中进行查询，进行注册或返回异常（如重复用户名）等操作</li><li><code>login</code> ，<code>logout</code>时对身份<code>token</code>进行验证后，更新数据库并返回用户的请求状态，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息</li><li><code>getFriends</code>时，根据用户名查询数据库，进行数据更新并返回好友列表</li><li>发送消息时，客户端请求<code>sendMsg</code>，向服务器发出消息及接收方和发送时间；服务器接到该报文后解析出被发送方，然后通过<strong><code>sendToFriend</code></strong>查询数据库得到被发送方的信息是否合法，该用户是否在线等，并通过<code>Map</code>得到该用户对应的socket连接。若是均符合条件，调用<strong><code>sendTo</code></strong>对消息进行转发，主动发给消息接收方</li><li>发送图片和文件类型的消息流程基本一致，函数分别为<code>sendPicsToFriend</code>, <code>sendPics</code>和<code>sendFileToFriends</code>, <code>sendFile</code></li><li>添加好友与发送消息时类似，用户将请求发送给服务器，然后由服务器通过被请求方对应的socket连接进行转发。其中<code>makeFriends</code>进行数据库查询判断信息是否合法，并得到被请求方对应的socket连接，然后使用<code>sendFriendRequest</code>由服务器主动向被请求方转发好友请求</li><li>发送好友申请的结果流程与申请添加好友一致，函数为<code>makeFriendsCheck</code>和<code>sendResquestRes</code></li><li>删除好友<code>deleteFriend</code>时，用户向服务器发出请求，服务器通过<code>deleteFriend</code>处理数据库中的好友关系表，实现对数据的更新，并返回给用户操作状态</li><li>发送图片和文件时，使用Socket的文件输入输出流<code>FileInputStream</code>和<code>FileOutputStream</code>，进行字节流传输，以二进制流的方式进行传输</li></ul></li></ul></li></ul><h4 id="3-1-4-Tuple-java"><a href="#3-1-4-Tuple-java" class="headerlink" title="3.1.4 Tuple.java"></a>3.1.4 <strong><code>Tuple.java</code></strong></h4><ul><li>重写java的Tuple类，以实现服务器某些功能函数要求的多返回值情况</li></ul><h3 id="3-2-客户端技术细节"><a href="#3-2-客户端技术细节" class="headerlink" title="3.2 客户端技术细节"></a>3.2 客户端技术细节</h3><h4 id="3-2-1NetService-kt"><a href="#3-2-1NetService-kt" class="headerlink" title="3.2.1NetService.kt"></a>3.2.1<strong><code>NetService.kt</code></strong></h4><ul><li>该包下存放登录、注册等各种不同请求方法，和存放<strong><code>socket</code></strong></li><li>该文件下存放所有网络请求相关的方法，其中包括<ul><li><strong><code>loginService</code></strong>，进行登录请求同时接收服务器的回复，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息</li><li><strong><code>logoutService</code></strong>登出请求同时接收服务器的回复</li><li><strong><code>regiService</code></strong>注册请求同时接收服务器的回复</li><li><strong><code>friendsService</code></strong>接收好友列表同时接收服务器的回复</li><li><strong><code>deleteService</code></strong>删除好友同时接收服务器的回复</li><li><strong><code>makefriendsService</code></strong>添加好友同时接收服务器的回复</li><li><strong><code>confirmRequestService</code></strong>确认好友信息同时接收服务器的回复</li><li><strong><code>sendPictureService</code></strong>发送照片同时接收服务器的回复</li><li><strong><code>sendMessageService</code></strong>发送消息同时接收服务器的回答</li></ul></li></ul><h4 id="3-2-2-LoginBean-kt"><a href="#3-2-2-LoginBean-kt" class="headerlink" title="3.2.2 LoginBean.kt"></a>3.2.2 <code>LoginBean.kt</code></h4><ul><li>在该包下保存用于保存服务器请求的数据类</li><li>命名统一为<code>XXBean</code></li></ul><h4 id="3-2-3Items-kt"><a href="#3-2-3Items-kt" class="headerlink" title="3.2.3Items.kt"></a>3.2.3<code>Items.kt</code></h4><ul><li>在该包下保存<code>RecyclerView</code>解耦之后的各种<code>item</code></li><li>使用<code>RecyclerDSL</code></li></ul><h4 id="3-2-4UISupport-kt"><a href="#3-2-4UISupport-kt" class="headerlink" title="3.2.4UISupport.kt"></a>3.2.4<code>UISupport.kt</code></h4><ul><li>用于制作<strong>沉浸式状态栏</strong></li></ul><h4 id="3-2-5TabFragment"><a href="#3-2-5TabFragment" class="headerlink" title="3.2.5TabFragment"></a>3.2.5<code>TabFragment</code></h4><ul><li>提供了管理三个页面的三个方法：<ul><li>管理聊天界面：<code>setTalkList</code></li><li>管理好友界面：<code>setFriendList</code></li><li>管理设置：<code>setMineList</code></li></ul></li></ul><h4 id="3-2-6ItemAdapter"><a href="#3-2-6ItemAdapter" class="headerlink" title="3.2.6ItemAdapter"></a>3.2.6<code>ItemAdapter</code></h4><ul><li>用于管理聊天界面的<code>RecyclerView</code>的消息展示</li><li>通过<code>addItem</code>方法直接添加子项</li></ul><h4 id="3-2-7LoginActivity"><a href="#3-2-7LoginActivity" class="headerlink" title="3.2.7LoginActivity"></a>3.2.7<code>LoginActivity</code></h4><ul><li>登陆界面，监听两个<code>EditText</code>和一个<code>LoginButton</code></li></ul><h4 id="3-2-8MainActivity"><a href="#3-2-8MainActivity" class="headerlink" title="3.2.8MainActivity"></a>3.2.8<code>MainActivity</code></h4><ul><li>应用的总界面，有三个<code>Fragment</code>，分别为消息列表，好友列表和个人信息</li><li>使用<code>Handler</code>进行回调，进行线程间通信</li><li>外层是<code>Viewpager</code>，可以轻松实现页面间滑动</li></ul><h4 id="3-2-9TalkActivity"><a href="#3-2-9TalkActivity" class="headerlink" title="3.2.9TalkActivity"></a>3.2.9<code>TalkActivity</code></h4><ul><li>聊天界面</li><li>点九图实现气泡</li><li>使用<code>Handler</code>进行回调</li><li>可以发送消息、图片、文件</li><li>增加文件选择器，可从本地选择文件</li></ul><h4 id="3-2-10-MVP架构"><a href="#3-2-10-MVP架构" class="headerlink" title="3.2.10 MVP架构"></a>3.2.10 <code>MVP架构</code></h4><ul><li>对数据层（Model）、处理层（Presenter）和交互层（View）进行解耦</li><li>便于维护和根据特定需求进行修改</li></ul><h3 id="3-3-数据库技术细节"><a href="#3-3-数据库技术细节" class="headerlink" title="3.3 数据库技术细节"></a>3.3 数据库技术细节</h3><p>数据库中采用sql语句建立两个表，分别存储用户信息及用户好友关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> UserData(</span><br><span class="line">    userName <span class="built_in">VARCHAR</span> PRIMARY <span class="keyword">KEY</span>,<span class="comment">--用户名，作为主键</span></span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INTEGER</span>,<span class="comment">--用户id</span></span><br><span class="line">    <span class="keyword">passWord</span> <span class="built_in">VARCHAR</span>,<span class="comment">--密码</span></span><br><span class="line">    isOnline <span class="built_in">INTEGER</span>,<span class="comment">--用户在线状态</span></span><br><span class="line">    token <span class="built_in">INTEGER</span>);<span class="comment">--用于身份验证的token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> UserFriends(</span><br><span class="line">    userName <span class="built_in">VARCHAR</span>,<span class="comment">--用户名</span></span><br><span class="line">    friendName <span class="built_in">VARCHAR</span>,<span class="comment">--用户的好友名</span></span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>);<span class="comment">--用户id</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 主键的意义在于快速检索每个用户对应的socket</span></span><br></pre></td></tr></table></figure><p>其中userName存储用户名， ID作为与每个用户对应的Socket通信的标识，isOnline存储用户的在线离线状态，便于服务器在收到消息和好友申请时的判断和处理。</p><h2 id="4-难点重点回顾-以下代码均为示意，并非源代码"><a href="#4-难点重点回顾-以下代码均为示意，并非源代码" class="headerlink" title="4. 难点重点回顾(以下代码均为示意，并非源代码)"></a>4. 难点重点回顾(以下代码均为示意，并非源代码)</h2><h3 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><ul><li>最早时未使用统一的<code>Server</code>和 <code>clientMap</code>管理Socket连接，导致各个用户的连接之间出现数据相互影响的情况，后通过引入多线程处理消息和Map统一管理来解决这一问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Socket&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    client = <span class="keyword">this</span>.server.accept();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(client)).start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于TCP短连接的问题，导致连接不稳定，经常意外中断，后通过持续监听的心跳机制实现TCP长连接解决了该问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">assert</span> server != <span class="keyword">null</span>;</span><br><span class="line">    client = <span class="keyword">this</span>.server.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转发消息时经常误判需要被发送的socket并出现<code>wirterror</code>，后来通过封装为函数，通过传参的方式确定socket和报文格式解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String commonMSG = <span class="string">"HTTP/1.1 %code %msg\r\n"</span> +</span><br><span class="line"><span class="string">"Content-Type: application/json;charset=utf-8\r\n"</span> +</span><br><span class="line">                        <span class="string">"Connection: keep-alive\r\n"</span> +</span><br><span class="line">                        <span class="string">"Content-Length: %type_body\r\n\r\n"</span>;</span><br><span class="line">                        </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfos</span><span class="params">(Socket infoClient, String json)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String res = json + <span class="string">"\n"</span>;</span><br><span class="line">        OutputStream out = client.getOutputStream();</span><br><span class="line">        out.write(res.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-完整版接口文档"><a href="#5-完整版接口文档" class="headerlink" title="5. 完整版接口文档"></a>5. 完整版接口文档</h2><h4 id="1-返回报文的body组成-1"><a href="#1-返回报文的body组成-1" class="headerlink" title="1. 返回报文的body组成"></a>1. 返回报文的body组成</h4><p>每次服务器返回的报文body都会包含以下信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:code,  “msg”:”msg”,  “type”:”type” &#125;</span><br></pre></td></tr></table></figure><p>其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类</p><h4 id="2-用户注册-1"><a href="#2-用户注册-1" class="headerlink" title="2. 用户注册"></a>2. 用户注册</h4><p>接口路径为 <code>ip/register</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回报文的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”register” &#125;</span><br></pre></td></tr></table></figure><p>返回的code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">注册成功</td></tr><tr><td align="center">-1</td><td align="center">重复的用户名</td></tr></tbody></table><h4 id="3-用户登陆-1"><a href="#3-用户登陆-1" class="headerlink" title="3. 用户登陆"></a>3. 用户登陆</h4><p>接口路径为<code>ip/login</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”login”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">密码错误</td></tr><tr><td align="center">2</td><td align="center">已经在线了</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr></tbody></table><h4 id="4-用户登出-1"><a href="#4-用户登出-1" class="headerlink" title="4. 用户登出"></a>4. 用户登出</h4><p>路径<code>ip/logout</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “userName”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” offline” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">已经离线了</td></tr><tr><td align="center">2</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户不存在</td></tr></tbody></table><h4 id="5-获取好友列表-1"><a href="#5-获取好友列表-1" class="headerlink" title="5. 获取好友列表"></a>5. 获取好友列表</h4><p>路径<code>ip/friends</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friends”,  “friends”:[“friend1”,”friend2”] &#125; </span><br><span class="line">-- friends是一个jsonArray的数组</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr></tbody></table><h4 id="6-发送加好友请求"><a href="#6-发送加好友请求" class="headerlink" title="6. 发送加好友请求"></a>6. 发送加好友请求</h4><p>路径<code>ip/makefriends</code></p><p>请求报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345,  “newfriend”:”newfriend” &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” makefriend”, &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">请求发送成功</td></tr><tr><td align="center">1</td><td align="center">token 无效</td></tr><tr><td align="center">2</td><td align="center">已经是好友了</td></tr><tr><td align="center">3</td><td align="center">目标用户不存在</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">目标用户不在线</td></tr></tbody></table><p>请求只有在对方在线时在允许发送</p><h4 id="7-回复好友请求"><a href="#7-回复好友请求" class="headerlink" title="7. 回复好友请求"></a>7. 回复好友请求</h4><p>路径<code>ip/result</code></p><p>请求报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “from”:”A”,  “to”:”B”,  “token”:12345,  “status”:1 &#125;</span><br><span class="line">-- from 代表当前用户的用户名</span><br><span class="line">-- to 代表接受方的用户名</span><br><span class="line">-- status 代表回复的结果</span><br><span class="line">-- token用于身份验证，保证安全性</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; “code”:0,  “msg”:”msg”,  “type”:” result” &#125;</span><br></pre></td></tr></table></figure><p>code及msg;</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">已经是好友了</td></tr><tr><td align="center">3</td><td align="center">目标用户不存在</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">目标用户不在线</td></tr></tbody></table><h4 id="8-服务器端转发好友请求"><a href="#8-服务器端转发好友请求" class="headerlink" title="8. 服务器端转发好友请求"></a>8. 服务器端转发好友请求</h4><p>报文格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friendrequest”, “from”:”from” &#125;</span><br></pre></td></tr></table></figure><p>服务器收到用户发出的好友申请时，会主动向被申请方发出该消息</p><h4 id="9-服务器端转发好友请求的回复结果"><a href="#9-服务器端转发好友请求的回复结果" class="headerlink" title="9. 服务器端转发好友请求的回复结果"></a>9. 服务器端转发好友请求的回复结果</h4><p>报文格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” makefriendres” &#125;</span><br></pre></td></tr></table></figure><p>服务器收到被申请方的回复时，会主动向申请方发出该消息</p><h4 id="10-发送消息"><a href="#10-发送消息" class="headerlink" title="10. 发送消息"></a>10. 发送消息</h4><p>路径<code>ip/sendmsg</code></p><p>报文格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345, “to”:”to”, “msg”:”data” , "time":"time"&#125;</span><br></pre></td></tr></table></figure><p>返回格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” sendmsgres” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">发送成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">没有这个好友</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">当前用户不在线</td></tr></tbody></table><h4 id="11-服务器转发消息"><a href="#11-服务器转发消息" class="headerlink" title="11. 服务器转发消息"></a>11. 服务器转发消息</h4><p>报文格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "time":"time"&#125;</span><br></pre></td></tr></table></figure><p>当服务器收到客户端发送的消息时，该 json 由服务器主动发出。其中 code 总是 0，from 表示<br>发送方用户名，msg 为消息本体。 </p><h4 id="12-发送文件"><a href="#12-发送文件" class="headerlink" title="12. 发送文件"></a>12. 发送文件</h4><p>路径<code>ip/sendFile</code></p><p>报文格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "to": "to", "time":"time"， "filename": "filename"&#125;  </span><br><span class="line">- msg 发送文件转码的字节流</span><br><span class="line">- filename 发送文件名</span><br></pre></td></tr></table></figure><p>返回格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” sendfile” &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">发送成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">没有这个好友</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">当前用户不在线</td></tr></tbody></table><h4 id="13-服务器主动转发文件"><a href="#13-服务器主动转发文件" class="headerlink" title="13. 服务器主动转发文件"></a>13. 服务器主动转发文件</h4><p>发送报文</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "time":"time", "filename": "filename"&#125;  </span><br><span class="line">- msg 发送文件转码的字节流</span><br><span class="line">- filename 发送文件名</span><br></pre></td></tr></table></figure><h4 id="14-删除好友"><a href="#14-删除好友" class="headerlink" title="14. 删除好友"></a>14. 删除好友</h4><p>路径<code>ip/delete</code></p><p>报文格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345,  “friendname”:”friendname” &#125;</span><br></pre></td></tr></table></figure><p>返回格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” delete” &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">删除成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr></tbody></table><h2 id="6-运行截图"><a href="#6-运行截图" class="headerlink" title="6. 运行截图"></a>6. 运行截图</h2><p>由于Markdown排版问题可能略丑请见谅</p><h3 id="1-登陆及注册界面"><a href="#1-登陆及注册界面" class="headerlink" title="1.登陆及注册界面"></a>1.登陆及注册界面</h3><h4 id="默认"><a href="#默认" class="headerlink" title="默认"></a>默认</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172133872.png" alt="image-20191029172133872" style="zoom: 33%;"><h4 id="未注册"><a href="#未注册" class="headerlink" title="未注册"></a>未注册</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172241048.png" alt="image-20191029172241048" style="zoom: 33%;"><h4 id="注册时用户名重复"><a href="#注册时用户名重复" class="headerlink" title="注册时用户名重复"></a>注册时用户名重复</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172332397.png" alt="image-20191029172332397" style="zoom: 33%;"><h3 id="2-通讯录"><a href="#2-通讯录" class="headerlink" title="2.通讯录"></a>2.通讯录</h3><h4 id="默认-1"><a href="#默认-1" class="headerlink" title="默认"></a>默认</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172433389.png" alt="image-20191029172433389" style="zoom: 33%;"><h4 id="添加好友"><a href="#添加好友" class="headerlink" title="添加好友"></a>添加好友</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172541106.png" alt="image-20191029172541106" style="zoom:33%;"><h4 id="添加好友时目标好友离线"><a href="#添加好友时目标好友离线" class="headerlink" title="添加好友时目标好友离线"></a>添加好友时目标好友离线</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172626027.png" alt="image-20191029172626027" style="zoom:33%;"><h4 id="目标好友不存在"><a href="#目标好友不存在" class="headerlink" title="目标好友不存在"></a>目标好友不存在</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172713191.png" alt="image-20191029172713191" style="zoom:33%;"><h3 id="3-聊天界面"><a href="#3-聊天界面" class="headerlink" title="3.聊天界面"></a>3.聊天界面</h3><h4 id="默认-2"><a href="#默认-2" class="headerlink" title="默认"></a>默认</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172821989.png" alt="image-20191029172821989" style="zoom:33%;"><h4 id="聊天对象不是好友"><a href="#聊天对象不是好友" class="headerlink" title="聊天对象不是好友"></a>聊天对象不是好友</h4><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172857361.png" alt="image-20191029172857361" style="zoom:33%;"><h3 id="4-个人页面"><a href="#4-个人页面" class="headerlink" title="4.个人页面"></a>4.个人页面</h3><img src="/Users/septieme/Library/Application Support/typora-user-images/image-20191029172953117.png" alt="image-20191029172953117" style="zoom:33%;">]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android development </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始卷积神经网络（CNN）</title>
      <link href="/desirelife6.github.io/2019/09/02/%E5%88%9D%E8%AF%86%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89/"/>
      <url>/desirelife6.github.io/2019/09/02/%E5%88%9D%E8%AF%86%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h2><p>CNN和之 前介绍的神经网络一样，可以像乐高积木一样通过组装层来构建。不过， CNN中新出现了卷积层（Convolution层）和池化层（Pooling层）。此外，各层中传递的数据是有形状的数据（比如，3维数据）<br><img src="https://upload-images.jianshu.io/upload_images/14338022-88eb64d87c5ca018.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于CNN的网络结构"><br>靠近输出的层中使用了之前 的“ Affine - ReLU”组合。此外，最后的输出层中使用了之前的“Affine - Softmax”组合。这些都是一般的CNN中比较常见的结构。</p><h2 id="二、卷积层"><a href="#二、卷积层" class="headerlink" title="二、卷积层"></a>二、卷积层</h2><h3 id="2-1-卷积层的优势"><a href="#2-1-卷积层的优势" class="headerlink" title="2.1 卷积层的优势"></a>2.1 卷积层的优势</h3><p>在全连接层中，数据的形状被忽视了。以图像输入为例子，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。前面提到的使用 了MNIST数据集的例子中，输入图像就是1通道、高28像素、长28像素的（1, 28, 28）形状，但却被排成1列，以784个数据的形式输入到最开始的 Affine层。<br>而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此可以提取出邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距 较远的像素之间没有什么关联等值得提取的本质模式，利用与数据形状相关的信息。</p><h3 id="2-2-卷积运算（图像处理中的滤波器运算）"><a href="#2-2-卷积运算（图像处理中的滤波器运算）" class="headerlink" title="2.2 卷积运算（图像处理中的滤波器运算）"></a>2.2 卷积运算（图像处理中的滤波器运算）</h3><h4 id="2-2-1-卷积运算基本过程"><a href="#2-2-1-卷积运算基本过程" class="headerlink" title="2.2.1 卷积运算基本过程"></a>2.2.1 卷积运算基本过程</h4><p>先来看一个经过卷积运算的结果<br><img src="https://upload-images.jianshu.io/upload_images/14338022-24f0c5a16d1cb7ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷积运算的例子"><br>对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指下图中灰色的3×3的部分。如下图所示，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。然后，将这个结果保存到输出的对应位置。将这个过程在所有位置都进行一遍，就可以得到卷积运算的输出。 如果有偏置，则在卷积运算结果的各个位置都加上偏置的值。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-6276ce0f20cd1a70.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷积运算的过程"></p><h4 id="2-2-2-填充"><a href="#2-2-2-填充" class="headerlink" title="2.2.2 填充"></a>2.2.2 填充</h4><p>在卷积神经网络中引入了填充和步幅等特殊概念，这里我们来介绍一下填充。<br>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding），是卷积运算中经常会用到的处理。比如， 在下图的例子中，对大小为(4, 4)的输入数据应用了幅度为1的填充。“幅度为1的填充”是指用幅度为1像素的0填充周围。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-a24b7e88ba4c56be.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="虚线表示填充，并省略了填充内容0"><br>可以看到，通过填充，大小为(4, 4)的输入数据变成了(6,6)的形状。 然后，应用大小为(3, 3)的滤波器，生成了大小为(4,4)的输出数据。这个例子中将填充的值设成了1，不过填充的值也可以设置成2、3等任意的整数。在图该例子中，如果将填充设为2，则输入数据的大小变为(8,8)；如果将填充设 为3，则大小变为(10, 10)。</p><blockquote><p>使用填充主要是为了调整输出的大小。比如，对大小为(4, 4)的输入数据应用(3,3)的滤波器时，输出大小变为(2, 2)，相当于输出大小比输入大小缩小了2个元素。在反复进行多次卷积运算的深度网络中,如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能变为1，导致无法再应用卷积运算。</p></blockquote><h4 id="2-2-3-步幅"><a href="#2-2-3-步幅" class="headerlink" title="2.2.3 步幅"></a>2.2.3 步幅</h4><p>介绍完填充，再来介绍一下步幅。步幅是应用滤波器的位置间隔，以下是步幅为2的情况。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-03e0bd8022ca55b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="步幅为2的卷积运算"></p><h4 id="2-2-4-填充，步幅和输出结果的瓜系"><a href="#2-2-4-填充，步幅和输出结果的瓜系" class="headerlink" title="2.2.4 填充，步幅和输出结果的瓜系"></a>2.2.4 填充，步幅和输出结果的瓜系</h4><p>增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。 如果将这样的关系写成算式，会如何呢？<br>我们看一下对于填充和步幅，如何计算输出大小。 这里，假设输入大小为(H,W)，滤波器大小为(FH,FW)，输出大小为 (OH,OW)，填充为P，步幅为S。此时，输出大小可通过下列式子计算。</p><hr><p>$$ OH = \frac{H+2P-FH}{S} + 1 $$</p><p>$$ OW = \frac{H+2P-FW}{S} + 1 $$</p><hr><p><strong>我们来思考一个问题，为什么卷积运算是有效的？</strong><br>依然用例子来说明，比如我们有一个4*4的图像，我们设计两个卷积核，看看运用卷积核后图片会变成什么样。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-df99b193ffbecc6c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="卷积操作后的特征映射图"><br>从结果可以看出，通过第一个卷积核计算后的特征图是一个三维数据，在第三列的绝对值最大，说明原始图片上对应的地方有一条垂直方向的特征，即像素数值变化较大；<br>而通过第二个卷积核计算后，第三列的数值为0，第二行的数值绝对值最大，说明原始图片上对应的地方有一条水平方向的特征，即像素值数值变化较大。<br>这样就提取出了大致的两个特征，通过在更深层次的网络中设置更多更巧妙的卷积核，我们就可以得到更多更准确的特征。<br>我们设计的卷积核分别能够提取，或者说检测出原始图片的特定的特征。所以实际上就可以把卷积核理解为特征提取器，我们不需要手动去选取特征，只用设计好卷积核的尺寸，数量和滑动的步长就可以让它自己去训练了。同时，由于多个神经元可以共享卷积核，对于高位数据的处理将会变得非常简单。<br>留下几个小问题供大家思考：</p><p>1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？</p><p>2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ </p><p>3.步长的向右和向下移动的幅度必须是一样的吗？</p><p>在最后我将给出这些问题的答案。</p><h4 id="2-2-5-多通道图的卷积运算"><a href="#2-2-5-多通道图的卷积运算" class="headerlink" title="2.2.5 多通道图的卷积运算"></a>2.2.5 多通道图的卷积运算</h4><p>这里先介绍单通道图和多通道图的概念<br>（一）：单通道图<br>俗称灰度图，每个像素点只能有有一个值表示颜色，它的像素值在0到255之间，0是黑色，255是白色，中间值是一些不同等级的灰色。（也有3通道的灰度图，3通道灰度图只有一个通道有值，其他两个通道的值都是零）。<br>（二）:三通道图<br>每个像素点都有3个值表示 ，所以就是3通道。也有4通道的图。例如RGB图片即为三通道图片，RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。总之，每一个点由三个值表示。</p><p>之前的卷积运算的例子都是以有高、长方向的2维形状的单通道图为对象的。<br>但是， 图像是3维数据，除了高、长方向之外，还需要处理通道方向。这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。这里以3通道的数据为例， 展示了卷积运算的结果。和2维数据时相比，可以发现纵深方向（通道方向）上特征图增加了。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-84df90c4dbb336eb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对三维数据进行卷积运算"><br>需要注意的是，在3维数据的卷积运算中，输入数据和滤波器的通道数要设为相同的值。从上图可知，每个卷积核输出一张特征图，而多个卷积核输出的特征图汇集在一起，传递给下一层，这就是CNN的处理流。<br>最后再看看一看卷积运算中的处理流是什么亚子。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-042342718ce8a343.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="基于多卷积核的卷积运算"></p><h2 id="三、-池化"><a href="#三、-池化" class="headerlink" title="三、 池化"></a>三、 池化</h2><p>讲了这么久的卷积，终于来到了池化（pooling）层<br>池化是缩小高、长方向上的空间的运算。比如，如图所示，进行将 2×2的区域集约成1个元素的处理，缩小空间大小。一般来说，池化的窗口大小会 和步幅设定成相同的值。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-1488813e8426f827.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Max池化"></p><blockquote><p>除了MaxPooling之外，还有AveragePooling等。相对于MaxPooling是从目标区域中取出最大值，AveragePooling则是计算目标区域的平均值。 在图像识别领域，主要使用MaxPooling。</p></blockquote><p><strong>那么问题来了，为什么MaxPooling能起到效果呢</strong><br>MaxPooling意义在哪里？如果我们只取最大值，那其他的值被舍弃难道就没有影响吗？不会损失这部分信息吗？如果认为这些信息是可损失的，那么是否意味着我们在进行卷积操作后仍然产生了一些不必要的冗余信息呢？</p><p>其实从上文分析卷积核为什么有效的原因来看，每一个卷积核可以看做一个特征提取器，不同的卷积核负责提取不同的特征，我们例子中设计的第一个卷积核能够提取出“垂直”方向的特征，第二个卷积核能够提取出“水平”方向的特征，那么我们对其进行MaxPooling操作后，提取出的是真正能够识别特征的数值，其余被舍弃的数值，对于我提取特定的特征并没有特别大的帮助。<br>在进行后续计算时，就减小了特征图的尺寸，从而减少参数，达到减小计算量，缺不损失效果的情况。</p><p>这也意味着MaxPooling对微小的位置变化具有健壮性，输入数据发生微小偏差时，池化仍会返回相同的结果,池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。</p><p>不过并不是所有情况MaxPooling的效果都很好，有时候有些周边信息也会对某个特定特征的识别产生一定效果，那么这个时候舍弃这部分“不重要”的信息，就不划算了。所以还要具体情况具体分析，如果加了Max Pooling后效果反而变差了，不如把卷积后不加MaxPooling的结果与卷积后加了MaxPooling的结果输出对比一下，看看MaxPooling是否对卷积核提取特征起了反效果。</p><h4 id="3-1-Flatten层-amp-Fully-Connected-Layer"><a href="#3-1-Flatten层-amp-Fully-Connected-Layer" class="headerlink" title="3.1 Flatten层 &amp; Fully Connected Layer"></a>3.1 Flatten层 &amp; Fully Connected Layer</h4><p>　　到这一步，其实我们的一个完整的“卷积部分”就算完成了，如果想要叠加层数，一般也是叠加“Conv-MaxPooing”,通过不断的设计卷积核的尺寸，数量，提取更多的特征，最后识别不同类别的物体。做完MaxPooling后，我们就会把这些数据“拍平”，丢到Flatten层，然后把Flatten层的output放到full connected Layer里，采用softmax对其进行分类。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-b5889eddf2a88735.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="Flatten过程"></p><h2 id="四、-CNN的可视化"><a href="#四、-CNN的可视化" class="headerlink" title="四、 CNN的可视化"></a>四、 CNN的可视化</h2><p>学习前的滤波器是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。我们发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-b37d408f9fd778c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="学习前后的权重参数（滤波器）"><br>如果要问右边的有规律的滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。比如，左半部分为白色、右半部分为黑色的滤波器的情况下，如图所示，会对垂直方向上的边缘有响应。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-a955bb70a401e05b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对水平边缘和垂直边缘有响应的滤波器"></p><h2 id="五、问题小结"><a href="#五、问题小结" class="headerlink" title="五、问题小结"></a>五、问题小结</h2><p>最后是上面给大家留下的问题<br>1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？</p><p>2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ </p><p>3.步长的向右和向下移动的幅度必须是一样的吗？</p><p>下面的想法，可以作为参考：</p><p>1.卷积核的尺寸不一定非得为正方形。长方形也可以，只不过通常情况下为正方形。如果要设置为长方形，那么首先得保证这层的输出形状是整数，不能是小数（一些框架会对小数进行四舍五入处理，一些会引起报错）。如果你的图像是边长为 28 的正方形。那么卷积层的输出就满足 [ (28 - kernel_size)/ stride ] + 1 ，这个数值得是整数才行，否则没有物理意义。池化层同理。FC 层的输出形状总是满足整数，其唯一的要求就是整个训练过程中 FC 层的输入得是定长的。如果你的图像不是正方形。那么在制作数据时，可以缩放到统一大小（非正方形），再使用非正方形的卷积核来使得卷积层的输出依然是整数。总之，撇开网络结果设定的好坏不谈，其本质上就是在做算术应用题：如何使得各层的输出是整数。 </p><p>2.由经验确定。通常情况下，靠近输入的卷积层，譬如第一层卷积层，会找出一些共性的特征，如手写数字识别中第一层我们设定卷积核个数为5个，一般是找出诸如”横线”、“竖线”、“斜线”等共性特征，我们称之为basic feature，经过池化后，在第二层卷积层，设定卷积核个数为20个，可以找出一些相对复杂的特征，如“横折”、“左半圆”、“右半圆”等特征，越往后，卷积核设定的数目越多，越能体现的特征就越细致，就越容易分类出来。比如你想分类出“0”的数字，你看到<img src="https://upload-images.jianshu.io/upload_images/14338022-c96a994eddf32808.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这个特征，能推测是什么数字呢？只有越往后，检测识别的特征越多，试过才能慢慢能识别出<img src="https://upload-images.jianshu.io/upload_images/14338022-8349cb5b6a35b9ca.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image"><br>这几个特征，那么我就能够确定这个数字是“0”。 </p><p>　　3.有stride_w和stride_h，表示左右步长和上下步长。如果用stride，则表示stride_h=stride_w=stride。</p>]]></content>
      
      
      <categories>
          
          <category> neural network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CNN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络的反向误差传播</title>
      <link href="/desirelife6.github.io/2019/08/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/"/>
      <url>/desirelife6.github.io/2019/08/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="一、一般的全连接神经网络结构"><a href="#一、一般的全连接神经网络结构" class="headerlink" title="一、一般的全连接神经网络结构"></a>一、一般的全连接神经网络结构</h2><h3 id="1-1-“层”的概念"><a href="#1-1-“层”的概念" class="headerlink" title="1.1 “层”的概念"></a>1.1 “层”的概念</h3><p>每个“层”在神经网络中被实现为一个类，作为神经网络中的功能单位，类中定义了此层接受的输入，运算和输出。比如，负责激活函数的层就是Sigmoid层，ReLU层等等，负责矩阵相乘的就是上次提到的Affine层。<br>以Affine层和ReLU层为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Affine</span><br><span class="line">X = np.random.rand(<span class="number">2</span>)  <span class="comment"># 输入</span></span><br><span class="line">W = np.random.rand(<span class="number">2</span>，<span class="number">3</span>)  <span class="comment"># 权重参数</span></span><br><span class="line">B = np.random.rand(<span class="number">3</span>)  <span class="comment"># 偏置</span></span><br><span class="line">Y = np.dot(X, W) + B    <span class="comment"># 得到相乘结果</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Relu</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        self.mask = <span class="literal">None</span>        <span class="comment"># mask这个变量在反向传播时很重要，稍后会提到</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span>        <span class="comment"># 正向传播</span></span><br><span class="line">        self.mask = (x &lt;= <span class="number">0</span>)        </span><br><span class="line">        out = x.copy()        </span><br><span class="line">        out[self.mask] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dout)</span>:</span>        <span class="comment"># 反向传播</span></span><br><span class="line">        dout[self.mask] = <span class="number">0</span>        </span><br><span class="line">        dx = dout</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/14338022-476c9832f7313def.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1-1 神经网络示意图"></p><p><img src="https://upload-images.jianshu.io/upload_images/14338022-bf9fe52bbc7d1934.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1-2 简单神经网络的结构"><br>这里Affine中的 X、W、B 分别是形状为 (2,)、(2,3)、(3,) 的多维数组。这样一来，神经元的加权和可以用 Y = np.dot(X, W) + B 计算出来。然后，Y 经过激活函数转换后，传递给下一层。这就是神经网络正向传播的流程。调用激活层中的 forward 正向传播。</p><h2 id="二、正向传播时的梯度下降法"><a href="#二、正向传播时的梯度下降法" class="headerlink" title="二、正向传播时的梯度下降法"></a>二、正向传播时的梯度下降法</h2><p>在正向传播中，采用数值微分法求梯度<br>在每一层，采用数值微分法分别求损失函数对于该层的各个权重参数的偏导数，组合成梯度，然后令各参数向梯度下降的方向更新。代码其实很好懂，简直就像大白话，这里举一个简单的例子。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numerical_gradient</span><span class="params">(f, x)</span>:</span>    <span class="comment"># x为传入的各参数的数组/多维数组</span></span><br><span class="line">    h = <span class="number">1e-4</span> <span class="comment"># 0.0001    </span></span><br><span class="line">    grad = np.zeros_like(x) <span class="comment"># 生成和x形状相同的数组</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(x.size):        </span><br><span class="line">        tmp_val = x[idx]    </span><br><span class="line">         <span class="comment"># f(x+h)的计算           </span></span><br><span class="line">        x[idx] = tmp_val + h        </span><br><span class="line">        fxh1 = f(x)</span><br><span class="line">        <span class="comment"># f(x-h)的计算        </span></span><br><span class="line">        x[idx] = tmp_val - h        </span><br><span class="line">        fxh2 = f(x)</span><br><span class="line">        <span class="comment"># 组合为梯度</span></span><br><span class="line">        grad[idx] = (fxh1 - fxh2) / (<span class="number">2</span>*h)        </span><br><span class="line">        x[idx] = tmp_val <span class="comment"># 还原值</span></span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(f, init_x, lr=<span class="number">0.01</span>, step_num=<span class="number">100</span>)</span>:</span>  </span><br><span class="line">    x = init_x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(step_num):       </span><br><span class="line">        grad = numerical_gradient(f, x)        </span><br><span class="line">        x -= lr * grad</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p><p>梯度下降法的函数的参数中，f 为我们选用的损失函数，x为各层传入的参数数组，lr为学习率，也就是参数每次更新的程度，step_num为更新的轮数。</p><p><strong>这就是通过数值微分法计算损失函数关于权重参数的梯度。数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。<br>所以我们将学习一个能够高效计算权重参数的梯度的方法——误差反向传播法。</strong> </p><h2 id="三、误差反向传播法"><a href="#三、误差反向传播法" class="headerlink" title="三、误差反向传播法"></a>三、误差反向传播法</h2><h3 id="3-1-计算图"><a href="#3-1-计算图" class="headerlink" title="3.1 计算图"></a>3.1 计算图</h3><h4 id="3-1-1-利用计算图求解"><a href="#3-1-1-利用计算图求解" class="headerlink" title="3.1.1 利用计算图求解"></a>3.1.1 利用计算图求解</h4><p>计算图解题的情况下，需要按如下流程进行</p><ol><li>构建计算图。 </li><li>在计算图上，从左向右进行计算。（正向传播）</li></ol><p>现在我们尝试用计算图求解简单的问题<br>问题1： 太郎在超市买了2个100元一个的苹果，消费税是10%，请计算支付金额。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-9e3ec7e96920e915.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-1 计算图求解问题1"></p><p>问题2：太郎在超市买了2个苹果、3个橘子。其中，苹果每个100元， 橘子每个150元。消费税是10%，请计算支付金额。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-bb50c362ac94ef56.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-2 计算图求解问题2"></p><h4 id="3-1-2-局部计算"><a href="#3-1-2-局部计算" class="headerlink" title="3.1.2 局部计算"></a>3.1.2 局部计算</h4><p>计算图的特征是可以通过传递“局部计算”获得最终结果。“局部”这个 词的意思是“与自己相关的某个小范围”。局部计算是指，无论全局发生了什么， 都能只根据与自己相关的信息输出接下来的结果。<br>我们用一个具体的例子来说明局部计算。比如，在超市买了2个苹果和其他很多东西。此时，可以画出如图3-3所示的计算图。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-9c0c549cb907e469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-3 局部计算"></p><p>如图3-3所示，假设（经过复杂的计算）购买的其他很多东西总共花费4000元。这里的重点是，各个节点处的计算都是局部计算。这意味着，例如苹果和其他很多东西的求和运算（4000 + 200 → 4200）并不关心4000这个数字是如何计算而来的，只要把两个数字相加就可以了。换言之，各个节点处只需进行与自己有关的计算（在这个例子中是对输入的两个数字进行加法运算），不用考虑全局。<br>综上，计算图可以集中精力于局部计算。无论全局的计算有多么复杂， 各个步骤所要做的就是对象节点的局部计算。虽然局部计算非常简单，但是通过传递它的计算结果，可以获得全局的复杂计算的结果。</p><h4 id="3-1-3-为何使用计算图"><a href="#3-1-3-为何使用计算图" class="headerlink" title="3.1.3 为何使用计算图"></a>3.1.3 为何使用计算图</h4><p>实际上，使用计算图最大的原因是，可以通过反向传播高效计算导数。 在介绍计算图的反向传播时，我们再来思考一下问题1。问题1中，假设我们想知道苹果价格的上涨会在多大程度上影响最终的支付金额，即求“支付金额关于苹果的价格的导数”。设苹果的价格为 x，支付金额为 L，则相当于求 $ \frac{dL}{dX} $。<br>先来看一下结果，如图3-4所示，可以通过计算图的反向传播求导数（关于如何进行反向传播，接下来马上会介绍）。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-10e378e162715943.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-2 反向传播求导数"><br>如图3-4所示，反向传播使用与正方向相反的箭头（粗线）表示。反向传播传递“局部导数”，将导数的值写在箭头的下方。在这个例子中，反向传播从右向左传递导数的值（1→1.1→2.2）。从这个结果中可知，“支付金额关于苹果的价格的导数”的值是2.2</p><p>“支付金额关于消费税的导数”“支付金额关于苹果的个数的导数”等也都可以用同样的方式算出来。并且, 计算中途求得的导数的结果（中间传递的导数）可以被共享，从而可以高效地计算多个导数。综上，计算图的优点是，可以通过正向传播和反向传 播高效地计算各个变量的导数值。</p><h3 id="3-2-链式法则"><a href="#3-2-链式法则" class="headerlink" title="3.2  链式法则"></a>3.2  链式法则</h3><h4 id="3-2-1-计算图的反向传播"><a href="#3-2-1-计算图的反向传播" class="headerlink" title="3.2.1 计算图的反向传播"></a>3.2.1 计算图的反向传播</h4><p>话不多说，让我们先来看一个使用计算图的反向传播的例子。假设存在 y = f(x)的计算，这个计算的反向传播如图3-4所示。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-ebb7d7543a0b5ada.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-4 计算图的反向传播"></p><p>如图所示，反向传播的计算顺序是，将信号E乘以节点的局部导数 （ $\frac{dy}{dx}$），然后将结果传递给下一个节点。这里所说的局部导数是指正向传播中$y = f(x) $的导数，也就是y关于x的导数（ $\frac{dy}{dx}$）。把这个局部导数乘以上游传过来的值（本例中为E）， 然后传递给前面的节点。</p><h4 id="3-2-2-链式法则"><a href="#3-2-2-链式法则" class="headerlink" title="3.2.2 链式法则"></a>3.2.2 链式法则</h4><p>链式法则是关于复合函数的导数的性质，定义如下。</p><blockquote><p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。</p></blockquote><p>形如 $\frac{dZ}{dX}  =  \frac{dZ}{dt}  \frac{dt}{dZ} $， 即为求导的链式法则。高数内容，不再赘述。</p><h4 id="3-2-3-链式法则与计算图"><a href="#3-2-3-链式法则与计算图" class="headerlink" title="3.2.3 链式法则与计算图"></a>3.2.3 链式法则与计算图</h4><p>现在我们尝试将上式的链式法则的计算用计算图表示出来。如果用 “**2”节点表示平方运算的话，则计算图如图3-5所示。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-faaa0b9e9106880e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-5 链式法则的计算图表示"><br>因为$\frac{dz}{dt} = 2t $; $\frac{dt}{dx} = 1 $ ; 所以$\frac{dz}{dx}  = 2(x+y) $</p><h3 id="3-3-反向传播"><a href="#3-3-反向传播" class="headerlink" title="3.3 反向传播"></a>3.3 反向传播</h3><h4 id="3-3-1-加法的反向传播"><a href="#3-3-1-加法的反向传播" class="headerlink" title="3.3.1 加法的反向传播"></a>3.3.1 加法的反向传播</h4><p>加法反向传播将从上游传过来的导数（本例中是 ）乘以 1，然 后传向下游。也就是说，因为加法节点的反向传播只乘以1，所以输入的值 会原封不动地流向下一个节点。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-8c39f66c66b71021.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-6 加法的反向传播"><br><img src="https://upload-images.jianshu.io/upload_images/14338022-4a2ec924f87098a4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-7 加法的具体例子"></p><h4 id="3-3-2-乘法的反向传播"><a href="#3-3-2-乘法的反向传播" class="headerlink" title="3.3.2 乘法的反向传播"></a>3.3.2 乘法的反向传播</h4><p>乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值” 后传递给下游。翻转值表示一种翻转关系，如图5-12所示，正向传播时信号 是x的话，反向传播时则是y；正向传播时信号是y的话，反向传播时则是x。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-3c46477a352904ce.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-8 乘法反向传播"></p><p> <img src="https://upload-images.jianshu.io/upload_images/14338022-ea38076a4e55f33b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-9 乘法的具体例子"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>结合加法和乘法，以苹果为例，尝试填入这些空格</p><p><img src="https://upload-images.jianshu.io/upload_images/14338022-f4c7245e87e25ae5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-10 苹果问题的反向传播练习"></p><p><img src="https://upload-images.jianshu.io/upload_images/14338022-09ff8b433b17389e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-11 苹果问题答案"></p><h3 id="3-4-激活函数层的反向传播实现"><a href="#3-4-激活函数层的反向传播实现" class="headerlink" title="3.4 激活函数层的反向传播实现"></a>3.4 激活函数层的反向传播实现</h3><h4 id="3-4-1-ReLU-层"><a href="#3-4-1-ReLU-层" class="headerlink" title="3.4.1 ReLU 层"></a>3.4.1 ReLU 层</h4><p>激活函数ReLU的导数为<img src="https://upload-images.jianshu.io/upload_images/14338022-e6b98c30e408bbd3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt><br>如果正向传播时的输入x大于0，则反向传播会将上游的 值原封不动地传给下游。反过来，如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处<br>所以在开始时提到的ReLU层的mask变量，是用来存储正向传播输入是否为0的变量，它是由True/False构成的NumPy数组，它会把正向传播时的输入x的元素中小于等于0的地方保存为True，其他地方（大于0的元素）保存为False。在反向传播中尤其重要。<br>计算图表示即为<img src="https://upload-images.jianshu.io/upload_images/14338022-35231df4b6a9dfa3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="3-4-2-Sigmoid层"><a href="#3-4-2-Sigmoid层" class="headerlink" title="3.4.2 Sigmoid层"></a>3.4.2 Sigmoid层</h4><p>步骤1<br>“/”节点表示 ，它的导数可以解析性地表示为下式。<br>$ \frac{dy}{dx} = - \frac{1}{x^2} = - y^2 $<br>反向传播时，会将上游的值乘以$−y^2$（正向传播的输出的平方乘以−1后的值）后，再传给下游。</p><p>步骤2<br> “+”节点将上游的值原封不动地传给下游。</p><p>步骤3<br>“exp”节点表示y = exp(x)，它的导数由下式表示。<br>$ \frac{dy}{dx} = exp(x) $<br>计算图中，上游的值乘以正向传播时的输出（这个例子中是exp(−x)）后， 再传给下游。</p><p>步骤4<br>“×”节点将正向传播时的值翻转后做乘法运算。因此，这里要乘以−1。</p><p>最终结果为</p><p><img src="https://upload-images.jianshu.io/upload_images/14338022-d0acf711f3e79f2d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-12 Sigmoid层的计算图"><br>这里要注意， 这个值只根据正向传播时的输入x和输出y就可以算出来,所以sigmoid的计算图可以简化为sigmoid节点，简洁版的计算图可以省略反向传播中的计算过程，因此计算效率更高。此外， 通过对节点进行集约化，可以不用在意Sigmoid层中琐碎的细节，而只需要专注它的输入和输出，这一点也很重要。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-27e9bddf662daaf9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-13 Sigmoid层的简洁版计算图"></p><h3 id="3-5-Affine-Softmax层的实现"><a href="#3-5-Affine-Softmax层的实现" class="headerlink" title="3.5 Affine/Softmax层的实现"></a>3.5 Affine/Softmax层的实现</h3><h4 id="3-5-1-Affine层"><a href="#3-5-1-Affine层" class="headerlink" title="3.5.1 Affine层"></a>3.5.1 Affine层</h4><p>神经网络的正向传播中，为了计算加权信号的总和，使用了矩阵的乘积运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Affine</span><br><span class="line">X = np.random.rand(<span class="number">2</span>)  <span class="comment"># 输入</span></span><br><span class="line">W = np.random.rand(<span class="number">2</span>，<span class="number">3</span>)  <span class="comment"># 权重参数</span></span><br><span class="line">B = np.random.rand(<span class="number">3</span>)  <span class="comment"># 偏置</span></span><br><span class="line">Y = np.dot(X, W) + B    <span class="comment"># 得到相乘结果</span></span><br></pre></td></tr></table></figure><blockquote><p>神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿 射变换” A。因此，这里将进行仿射变换的处理实现为“Affine层”。</p></blockquote><p>现在将它用计算图表示出来，要注意X、W、B是矩阵（多维数组）。 之前我们见到的计算图中各个节点间流动的是标量，而这个例子中各个节点间传播的是矩阵。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-b75afdcbcd27ce45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-14 Affine层计算图"><br>现在我们来考虑图 3-14 的计算图的反向传播。以矩阵为对象的反向传播，通过数学推导可得到下式<br>$$ \frac{dL}{dX} = \frac{dL}{dY} * W^T $$<br>$$ \frac{dL}{dW} = X^T * \frac{dL}{dY} $$<br>表示为计算图即为：<br><img src="https://upload-images.jianshu.io/upload_images/14338022-8cffa4844e0182bb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-15Affine的反向传播"><br>其中值得注意的是,X与$\frac{dL}{dX}$形状相同，W与$\frac{dL}{dW}$形状相同,从下式也容易看出</p><p><img src="https://upload-images.jianshu.io/upload_images/14338022-2e7806efcaa77582.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt></p><h4 id="3-5-2-批版本的Affine层"><a href="#3-5-2-批版本的Affine层" class="headerlink" title="3.5.2 批版本的Affine层"></a>3.5.2 批版本的Affine层</h4><p>前面介绍的Affi  ne层的输入X是以单个数据为对象的。现在我们考虑N 个数据一起进行正向传播的情况，也就是批版本的Affine层。<br>先来看计算图<br><img src="https://upload-images.jianshu.io/upload_images/14338022-56a98d8ccd972ddc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-16 批版本Affine层"><br>与刚刚不同的是，现在输入X的形状是(N,2)。之后就和前面一样，在计算图上进行单纯的矩阵计算。<br><strong>加上偏置时，需要特别注意。正向传播时，偏置被加到X·W的各个数据上。比如，N = 2（数据为2个）时，偏置会被分别加到这2个数据（各自 的计算结果）上。因此， 反向传播时，各个数据的反向传播的值需要汇总为偏置的元素。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dY = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dY </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],       </span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dB = np.sum(dY, axis=<span class="number">0</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dB </span><br><span class="line">array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>这个例子中，假定数据有2个（N = 2）。偏置的反向传播会对这2个数据的导数按元素进行求和。因此，这里使用了np.sum()对第0轴（以数据为单位的轴，axis=0）方向上的元素进行求和。 </p><h4 id="3-5-3-Softmax-with-Loss-层"><a href="#3-5-3-Softmax-with-Loss-层" class="headerlink" title="3.5.3 Softmax-with-Loss 层"></a>3.5.3 Softmax-with-Loss 层</h4><p>上次我们提到过，softmax函数会将输入值正规化之后再输出。比如手写数字识别时，Softmax层的输出如下所示。<br><img src="https://upload-images.jianshu.io/upload_images/14338022-d9b6603ae324f3cb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=" 输入图像通过Aﬃne层和ReLU层进行转换，10个输入通过Softmax层进行正规化。在这个例子中，“0”的得分是5.3，这个值经过Softmax层转换为0.008 （0.8%）；“ 2”的得分是10.1，被转换为0.991（99.1%）"></p><blockquote><p>神经网络中进行的处理有推理（inference）和学习两个阶段。神经网络的推理通常不使用Softmax层。比如，用上图的网络进行推理时， 会将最后一个Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（Softmax层前面的Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要Softmax层。 不过，神经网络的学习阶段则需要Softmax层。</p></blockquote><p>来看softmax的计算图，导出过程比较复杂，这里只给出最终结果<br><img src="https://upload-images.jianshu.io/upload_images/14338022-15543240f74047ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="softmax计算图"></p><p>不感兴趣的话可以看简化版本<br><img src="https://upload-images.jianshu.io/upload_images/14338022-7654f8a925e92202.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="3-17 简化版softmax计算图"></p><p>Softmax层的反向传播得到了 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。由于$（y_1,y_2,y_3）$是 Softmax层的输出，$（ t_1,t_2,t_3）$是监督数据，所以$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$是 Softmax层的输出和教师标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层，这是神经网络学习中的重要性质。<br>神经网络学习的目的就是通过调整权重参数，使神经网络的输出（Softmax 的输出）接近教师标签。因此，必须将神经网络的输出与教师标签的误差高效地传递给前面的层。刚刚的$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$正是 Softmax层的输出与教师标签的差，直截了当地表示了当前神经网络的输出与教师标签的误差。 </p><blockquote><p>使用交叉熵误差作为softmax函数的损失函数后，反向传播得到 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样 “漂亮”的结果。实际上，这样“漂亮” 的结果并不是偶然的，而是为了得到这样的结果，特意设计了交叉熵误差函数。回归问题中输出层使用“恒等函数”，损失函数使用 “平方和误差”，也是出于同样的理由。也就是说，使用“平 方和误差”作为“恒等函数”的损失函数，反向传播才能得到$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。</p></blockquote><h2 id="四、神经网络学习全貌"><a href="#四、神经网络学习全貌" class="headerlink" title="四、神经网络学习全貌"></a>四、神经网络学习全貌</h2><p>前提<br>神经网络中有合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为学习<br>神经网络的学习分为下面4个步骤。<br>步骤1（mini-batch）<br>从训练数据中随机选择一部分数据。<br>步骤2（计算梯度）<br>计算损失函数关于各个权重参数的梯度。<br>步骤3（更新参数）<br>将权重参数沿梯度方向进行微小的更新。<br>步骤4（重复）<br>重复步骤1、步骤2、步骤3。<br>这次介绍的误差反向传播法会在步骤2中出现。上一次中，我们利用数值微分求得了这个梯度。数值微分虽然实现简单，但是计算要耗费较多的时间，而误差反向传播法可以快速高效地计算梯度。</p><p><strong>还有一篇CNN噢，欢迎持续关注 :-D</strong></p>]]></content>
      
      
      <categories>
          
          <category> neural network </category>
          
      </categories>
      
      
        <tags>
            
            <tag> neural network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/desirelife6.github.io/2019/08/30/hello-world/"/>
      <url>/desirelife6.github.io/2019/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于作者</title>
      <link href="/desirelife6.github.io/about/index.html"/>
      <url>/desirelife6.github.io/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><h3 id="我是一枚爱吃饭爱睡觉的可爱程序猿"><a href="#我是一枚爱吃饭爱睡觉的可爱程序猿" class="headerlink" title="我是一枚爱吃饭爱睡觉的可爱程序猿"></a>我是一枚爱吃饭爱睡觉的可爱程序猿</h3><h2 id="博客干嘛用"><a href="#博客干嘛用" class="headerlink" title="博客干嘛用"></a>博客干嘛用</h2><h3 id="我想干嘛干嘛鸭嘻嘻嘻"><a href="#我想干嘛干嘛鸭嘻嘻嘻" class="headerlink" title="我想干嘛干嘛鸭嘻嘻嘻"></a>我想干嘛干嘛鸭嘻嘻嘻</h3><p>其实可以来github给我star ： <a href="https://github.com/Desirelife6">https://github.com/Desirelife6</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/desirelife6.github.io/tags/index.html"/>
      <url>/desirelife6.github.io/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/desirelife6.github.io/categories/index.html"/>
      <url>/desirelife6.github.io/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
