<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android消息机制</title>
      <link href="/desirelife6.github.io/2020/04/10/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"/>
      <url>/desirelife6.github.io/2020/04/10/Android%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<p>Android的消息机制主要是指的<code>Handler</code>的运行机制以及<code>Handler</code>所附带的<code>MessageQueue</code>和<code>Looper</code>的工作过程，这三者实际上是一个整体。</p><a id="more"></a><p>从开发的角度来看，Handler是消息机制的上层接口，通过它我们可以轻松的将一个任务切换到它所在的线程中去执行。以消息传递为例，在一个线程创建Handler，另外一个线程通过持有该Handler的引用调用sendMessage实现消息在线程之间的传递。MessageQueue的中文翻译是消息队列，内部采用单链表的数据结构来存储消息列表。Looper的中文翻译是循环，这里可以理解为消息循环。由于MessageQueue只是一个消息的存储单元，它不能去处理消息，而Looper就填补了这个功能，<strong>Looper会以无限循环的形式去查找是否有新消息，如果有的话就处理消息，否则就一直等待着。</strong>Looper中还有一个特殊的概念：<code>ThreadLocal</code>，当我们调用<code>Looper.prepare()</code>方法创建Looper时使用到它。在Handler内部就是通过ThreadLocal来获取每个线程的Looper的。</p><p>Handler的内部实现主要涉及到如下几个类: Thread、MessageQueue和Looper。这几类之间的关系可以用如下的图来简单说明：</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.24.13.png" alt="截屏2020-04-1020.24.13"></p><p>Thread是最基础的，Looper和MessageQueue都构建在Thread之上，Handler又构建在Looper和MessageQueue之上，我们通过Handler间接地与下面这几个相对底层一点的类打交道。</p><p>下面我们来先分别介绍<code>ThreadLocal</code>，<code>MessageQueue</code>，<code>Looper</code>, 和<code>Handler</code>的工作机制，再将它们的工作流程进行一个大致的串讲。</p><h2 id="1-ThreadLocal"><a href="#1-ThreadLocal" class="headerlink" title="1. ThreadLocal"></a>1. ThreadLocal</h2><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h3><p><strong><code>ThreadLocal</code>是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据</strong>，数据存储以后，<strong>只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。</strong></p><p>上面的话可以理解为，<code>ThreadLocal</code>是一个全局变量，用来存储对应<code>Thread</code>的本地变量。当使用ThreadLocal维护变量时，ThreadLocal为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。 举一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MainActivity"</span>;</span><br><span class="line">    <span class="comment">//定义ThreadLocal对象</span></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Boolean&gt; mBooleanThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        mBooleanThreadLocal.set(<span class="keyword">true</span>);</span><br><span class="line">        Log.d(TAG, <span class="string">"[Thread#main]mBooleanThreadLocal="</span> + mBooleanThreadLocal.get());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread#1"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                mBooleanThreadLocal.set(<span class="keyword">false</span>);</span><br><span class="line">                Log.d(TAG, <span class="string">"[Thread#1]mBooleanThreadLocal="</span> + mBooleanThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="string">"Thread#2"</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"[Thread#2]mBooleanThreadLocal="</span> + mBooleanThreadLocal.get());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，在主线程中设置<code>mBooleanThreadLocal</code>的值为<code>true</code>，在子线程1中设置<code>mBooleanThreadLocal</code>值为<code>false</code>，子线程2中不设置<code>mBooleanThreadLocal</code>的值。然后在3个线程中分别通过<code>get</code>方法获取值并打印出来。根据前面的描述，<em>期望的打印结果应该是：主线程为<code>true</code>，子线程1为<code>false</code>，子线程2位<code>null</code></em>，因为子线程2中没有设置值。实际打印结果如下：</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.24.34.png" alt="截屏2020-04-1020.24.34"></p><p>可以看到，尽管在三个线程中访问的为同一个对象，但是ThreadLocal为他们各自维护了一个该对象的副本，所以访问到的结果不同。</p><h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h3><p><strong>ThreadLocal是一个泛型类</strong>，<code>public class ThreadLocal&lt;T&gt;</code>，要理解它的工作原理，可以从<code>get</code>和<code>set</code>方法入手，先来看<code>set</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Sets the current thread's copy of this thread-local variable</span></span><br><span class="line"><span class="comment">   * to the specified value.  Most subclasses will have no need to</span></span><br><span class="line"><span class="comment">   * override this method, relying solely on the &#123;<span class="doctag">@link</span> #initialValue&#125;</span></span><br><span class="line"><span class="comment">   * method to set the values of thread-locals.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class="line"><span class="comment">   *        this thread-local.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">      Thread t = Thread.currentThread();</span><br><span class="line">      ThreadLocalMap map = getMap(t);</span><br><span class="line">      <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">          map.set(<span class="keyword">this</span>, value);</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">          createMap(t, value);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>可见，首先通过<code>getMap</code>方法来获取当前线程中的<code>ThreadLocal</code>数据，如果返回的<code>ThreadLocalMap</code>对象不为空，则调用<code>set</code>方法添加数据，否则就创建一个新对象并把值添加进去。<code>ThreadLocalMap</code>中定义了一个<code>private Entry[] table;</code>来存储数据，我们可以通过<code>set</code>方法将数据添加到<code>table</code>数组中。</p><p>再来看看<code>get</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the value in the current thread's copy of this</span></span><br><span class="line"><span class="comment">     * thread-local variable.  If the variable has no value for the</span></span><br><span class="line"><span class="comment">     * current thread, it is first initialized to the value returned</span></span><br><span class="line"><span class="comment">     * by an invocation of the &#123;<span class="doctag">@link</span> #initialValue&#125; method.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the current thread's value of this thread-local</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以发现，<code>ThreadLocal</code>的<code>get</code>方法同样是先取出当前线程的<code>ThreadLocalMap</code> 对象，如果这个对象为<code>null</code>就返回初始值，这个初始值由<code>ThreadLocal</code>的<code>initialValue()</code>方法来确定，默认情况下为<code>null</code>，默认实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果<code>ThreadLocalMap</code> 对象不为<code>null</code>，那么就取出<code>table</code>数组并找到相应的值返回回去。</p><p>从<code>ThreadLocal</code>的<code>set</code>和<code>get</code>方法可以看出，它们所操作的对象都是当前线程的<code>ThreadLocalMap</code>对象的<code>table</code>数组，因此<strong>在不同线程中访问同一个<code>ThreadLocal</code>的<code>set</code>和<code>get</code>方法，它们对<code>ThreadLocal</code>所做的读/写操作仅限于各线程的内部</strong>，所以<code>ThreadLocal</code>可以在多个线程中互不干扰地存储和修改数据。</p><h3 id="3-与Android消息机制的联系"><a href="#3-与Android消息机制的联系" class="headerlink" title="3. 与Android消息机制的联系"></a>3. 与Android消息机制的联系</h3><p>当我们在一个线程中创建一个Handler，调用Looper.prepare()时通过ThreadLocal保存当前线程下的Looper对象，而所有线程的Looper都由一个ThreadLocal来维护，也就是在所有线程中创建的Looper都存放在了同一个ThreadLocal中。而Handler又与Looper协同工作，大致关系如下图：</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.24.49.png" alt="截屏2020-04-1020.24.49"></p><h2 id="2-MessageQueue"><a href="#2-MessageQueue" class="headerlink" title="2. MessageQueue"></a>2. MessageQueue</h2><p>最基础最底层的是Thread，每个线程内部都维护了一个消息队列——MessageQueue。消息队列MessageQueue，顾名思义，就是存放消息的队列（好像是废话…）。那队列中存储的消息是什么呢？假设我们在UI界面上单击了某个按钮，而此时程序又恰好收到了某个广播事件，那我们如何处理这两件事呢？ 因为一个线程在某一时刻只能处理一件事情，不能同时处理多件事情，所以我们不能同时处理按钮的单击事件和广播事件，我们只能挨个对其进行处理，只要挨个处理就要有处理的先后顺序。 为此Android把UI界面上单击按钮的事件封装成了一个Message，将其放入到MessageQueue里面去，即将单击按钮事件的Message入栈到消息队列中，然后再将广播事件的封装成以Message，也将其入栈到消息队列中。也就是说一个Message对象表示的是线程需要处理的一件事情，消息队列就是一堆需要处理的Message的池。线程Thread会依次取出消息队列中的消息，依次对其进行处理。MessageQueue中有两个比较重要的方法，一个是enqueueMessage方法，一个是next方法。enqueueMessage方法用于将一个Message放入到消息队列MessageQueue中，next方法是从消息队列MessageQueue中阻塞式地取出一个Message。</p><p><code>enqueueMessage</code>主要操作其实就是<strong>单链表的插入操作</strong>，这里就不再过多解释了。而<strong><code>next</code>方法是一个无限循环的方法，如果消息队列中没有消息，那么<code>next</code>方法会一直阻塞在这里。当有新消息到来时，<code>next</code>方法会返回这条消息并将其从单链表中移除。</strong></p><h2 id="3-Looper"><a href="#3-Looper" class="headerlink" title="3. Looper"></a>3. Looper</h2><h3 id="1-Looper的创建（使用ThreadLocal存储）"><a href="#1-Looper的创建（使用ThreadLocal存储）" class="headerlink" title="1. Looper的创建（使用ThreadLocal存储）"></a>1. Looper的创建（使用ThreadLocal存储）</h3><p><code>Looper</code>在<code>Android</code>的消息机制中扮演着消息循环的角色，具体来说就是<strong>它会不停地从<code>MessageQueue</code>中查看是否有新消息，如果有新消息就会立刻处理，否则就一直阻塞在哪里。</strong>首先来看一下它的构造方法，在构造方法中它会创建一个<code>MessageQueue</code>即消息队列，然后将当前线程的对象保存起来，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@UnsupportedAppUsage</span></span><br><span class="line"><span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line"><span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>创建<code>looper</code>时调用<code>looper.prepare</code>，具体操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sThreadLocal即为存储各线程Looper的ThreadLocal对象，调用其get方法判断该线程是否已经持有了Looper，如果已经持有则抛出异常，这是为了保证对于每个线程Looper的唯一性。如果没有Looper，则为该线程创建一个Looper。</p><h3 id="2-Looper的循环"><a href="#2-Looper的循环" class="headerlink" title="2. Looper的循环"></a>2. Looper的循环</h3><p>而<strong><code>Looper</code>最重要的一个方法是<code>loop</code>方法，只有调用了<code>loop</code>后，消息循环系统才会真正地起作用</strong>，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Run the message queue in this thread. Be sure to call</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Allow overriding a threshold with a system prop. e.g.</span></span><br><span class="line">        <span class="comment">// adb shell 'setprop log.looper.1000.main.slow 1 &amp;&amp; stop &amp;&amp; start'</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> thresholdOverride =</span><br><span class="line">                SystemProperties.getInt(<span class="string">"log.looper."</span></span><br><span class="line">                        + Process.myUid() + <span class="string">"."</span></span><br><span class="line">                        + Thread.currentThread().getName()</span><br><span class="line">                        + <span class="string">".slow"</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            <span class="keyword">final</span> Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.target + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Make sure the observer won't change while processing a transaction.</span></span><br><span class="line">            <span class="keyword">final</span> Observer observer = sObserver;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> traceTag = me.mTraceTag;</span><br><span class="line">            <span class="keyword">long</span> slowDispatchThresholdMs = me.mSlowDispatchThresholdMs;</span><br><span class="line">            <span class="keyword">long</span> slowDeliveryThresholdMs = me.mSlowDeliveryThresholdMs;</span><br><span class="line">            <span class="keyword">if</span> (thresholdOverride &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                slowDispatchThresholdMs = thresholdOverride;</span><br><span class="line">                slowDeliveryThresholdMs = thresholdOverride;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDelivery = (slowDeliveryThresholdMs &gt; <span class="number">0</span>) &amp;&amp; (msg.when &gt; <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> logSlowDispatch = (slowDispatchThresholdMs &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needStartTime = logSlowDelivery || logSlowDispatch;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> needEndTime = logSlowDispatch;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (traceTag != <span class="number">0</span> &amp;&amp; Trace.isTagEnabled(traceTag)) &#123;</span><br><span class="line">                Trace.traceBegin(traceTag, msg.target.getTraceName(msg));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchStart = needStartTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> dispatchEnd;</span><br><span class="line">            Object token = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                token = observer.messageDispatchStarting();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> origWorkSource = ThreadLocalWorkSource.setUid(msg.workSourceUid);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                msg.target.dispatchMessage(msg);</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.messageDispatched(token, msg);</span><br><span class="line">                &#125;</span><br><span class="line">                dispatchEnd = needEndTime ? SystemClock.uptimeMillis() : <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception exception) &#123;</span><br><span class="line">                <span class="keyword">if</span> (observer != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    observer.dispatchingThrewException(token, msg, exception);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">throw</span> exception;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                ThreadLocalWorkSource.restore(origWorkSource);</span><br><span class="line">                <span class="keyword">if</span> (traceTag != <span class="number">0</span>) &#123;</span><br><span class="line">                    Trace.traceEnd(traceTag);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDelivery) &#123;</span><br><span class="line">                <span class="keyword">if</span> (slowDeliveryDetected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((dispatchStart - msg.when) &lt;= <span class="number">10</span>) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Drained"</span>);</span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (showSlowLog(slowDeliveryThresholdMs, msg.when, dispatchStart, <span class="string">"delivery"</span>,</span><br><span class="line">                            msg)) &#123;</span><br><span class="line">                        <span class="comment">// Once we write a slow delivery log, suppress until the queue drains.</span></span><br><span class="line">                        slowDeliveryDetected = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (logSlowDispatch) &#123;</span><br><span class="line">                showSlowLog(slowDispatchThresholdMs, dispatchStart, dispatchEnd, <span class="string">"dispatch"</span>, msg);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.target + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.target.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>选取其中比较关键的部分做一下讲解：</p><ol><li><p>final MessageQueue queue = me.mQueue; </p><p>变量me是通过静态方法myLooper()获得的当前线程所绑定的Looper，me.mQueue是当前线程所关联的消息</p><p>队列。 </p></li><li><p>for (;;) </p><p>我们发现for循环没有设置循环终止的条件，所以这个for循环是个死循环。 </p></li><li><p>Message msg = queue.next(); // might block </p><p>我们通过消息队列MessageQueue的next方法从消息队列中取出一条消息，如果此时消息队列中有Message，</p><p>那么next方法会立即返回该Message，如果此时消息队列中没有Message，那么next方法就会阻塞式地等待获</p><p>取Message。 </p></li><li><p>msg.target.dispatchMessage(msg); </p><p>msg的target属性是Handler，该代码的意思是让Message所关联的Handler通过dispatchMessage方法让</p><p>Handler处理该Message，关于Handler的dispatchMessage方法将会在下面详细介绍。</p></li></ol><p><code>loop</code>方法是一个死循环，唯一跳出循环的方式是<code>MessageQueue</code>的<code>next</code>方法返回了<code>null</code>。</p><p>当<code>Looper</code>的quit方法被调用时，<code>Looper</code>就会调用<code>MessageQueue</code>的quit方法或quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的<code>next</code>方法就会返回<code>null</code>。如果<code>MessageQueue</code>的<code>next</code>方法返回了新消息，<code>Looper</code>就会处理这条消息： <code>msg.target.dispatchMessage(msg)</code>，这里的<strong><code>msg.target</code>是发送这条消息的<code>Handler</code>对象</strong>，这样<code>Handler</code>发送的消息最终又交给它的<code>dispatchMessage</code>方法来处理了。但是这里不同的是，<strong><code>Handler</code>的<code>dispatchMessage</code>方法是在创建<code>Handler</code>时所使用的<code>Looper</code>中执行的，这样就成功的将代码逻辑切换到指定的线程中去执行了。</strong></p><h2 id="4-Handler"><a href="#4-Handler" class="headerlink" title="4. Handler"></a>4. Handler</h2><h3 id="1-消息发送"><a href="#1-消息发送" class="headerlink" title="1. 消息发送"></a>1. 消息发送</h3><p><strong><code>Handler</code>的工作主要包含消息的发送和接收过程</strong>。消息的发送最终是通过<code>send</code>的一系列方法来实现的。发送一条消息的典型过程如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessage</span><span class="params">(Message msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sendMessageDelayed(msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">sendMessageDelayed</span><span class="params">(Message msg, <span class="keyword">long</span> delayMillis)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (delayMillis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        delayMillis = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sendMessageAtTime(msg, SystemClock.uptimeMillis() + delayMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    MessageQueue queue = mQueue;</span><br><span class="line">    <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">        Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> enqueueMessage(queue, msg, uptimeMillis);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">    msg.target = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> queue.enqueueMessage(msg, uptimeMillis);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在enqueueMessage中有两件事需要注意： </p><ol><li>msg.target = this<br>该代码将Message的target绑定为当前的Handler </li><li>queue.enqueueMessage<br>变量queue表示的是Handler所绑定的消息队列MessageQueue，通过调用queue.enqueueMessage(msg, uptimeMillis)我们将Message放入到消息队列中。</li></ol><p>其他的一些调用最终也都归结到上面这个流程中：</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.25.07.png" alt="截屏2020-04-1020.25.07"></p><h3 id="2-消息处理"><a href="#2-消息处理" class="headerlink" title="2. 消息处理"></a>2. 消息处理</h3><p>通过上文可以发现，<code>Handler</code>发送消息的过程仅仅是向消息队列插入了一条消息，<code>MessageQueue</code>的<code>next</code>方法就会返回这条消息给<code>Looper</code>，<code>Looper</code>收到消息后就开始处理了，<strong>最终消息由<code>Looper</code>交由<code>Handler</code>处理，即<code>Handler</code>的<code>dispatchMessage</code>方法会被调用</strong>，这时Handler就进入了处理消息的阶段。<code>dispatchMessage</code>的实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        handleCallback(msg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        handleMessage(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，如果我们设置了callback（Runnable对象）的话，则会直接调用handleCallback方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handleCallback</span><span class="params">(Message message)</span> </span>&#123;</span><br><span class="line">        message.callback.run();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>即，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。比如我们经常写的runOnUiThread方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runOnUiThread</span><span class="params">(Runnable action)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (Thread.currentThread() != mUiThread) &#123;</span><br><span class="line">          mHandler.post(action);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          action.run();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而如果msg.callback为空的话，会直接调用我们的mCallback.handleMessage(msg)，即handler的handlerMessage方法。handlerMessage方法的执行也会在创建handler的线程中。</p><p>综上，我们可以看到Handler提供了三种途径处理Message，而且处理有前后优先级之分：首先尝试让postXXX中传递的Runnable执行，其次尝试让Handler构造函数中传入的Callback的handleMessage方法处理，最后才是让Handler自身的handleMessage方法处理Message。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.25.22.png" alt="截屏2020-04-1020.25.22"></p><h3 id="3-post与send的比较"><a href="#3-post与send的比较" class="headerlink" title="3. post与send的比较"></a>3. post与send的比较</h3><p>上述例子都是使用send方法，这里加一个post的例子帮助理解handler对于不同类型信息的处理</p><p>首先，调用post方法时依然调用了sendMessageDelayed，但是值得注意的是这里的参数有所不同，使用了getPostMessage(r)作为参数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">post</span><span class="params">(Runnable r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span>  sendMessageDelayed(getPostMessage(r), <span class="number">0</span>);<span class="comment">//getPostMessage方法是两种发送消息的不同之处</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>那么我们来看一看👀这个getPostMessage方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Message <span class="title">getPostMessage</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">        Message m = Message.obtain();</span><br><span class="line">        m.callback = r;</span><br><span class="line">        <span class="keyword">return</span> m;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可以看到，依然是把Runnable对象封装成了一个Message进行发送，不过这里设置了m.callback = r ，这也呼应了上文中提到的，如果我们在初始化Handler的时候设置了callback（Runnable）对象，则直接调用run方法。</p><h3 id="4-Callback"><a href="#4-Callback" class="headerlink" title="4. Callback"></a>4. Callback</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Callback interface you can use when instantiating a Handler to avoid</span></span><br><span class="line"><span class="comment"> * having to implement your own subclass of Handler.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> msg A &#123;<span class="doctag">@link</span> android.os.Message Message&#125; object</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> True if no further handling is desired</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Handler.Callback是用来处理Message的一种手段，如果没有传递该参数，那么就应该重写Handler的handleMessage方法，也就是说为了使得Handler能够处理Message，我们有两种办法： </p><ol><li>向Hanlder的构造函数传入一个Handler.Callback对象，并实现Handler.Callback的handleMessage方法 </li><li>无需向Hanlder的构造函数传入Handler.Callback对象，但是需要重写Handler本身的handleMessage方法  </li></ol><p>也就是说无论哪种方式，我们都得通过某种方式实现handleMessage方法，这点与Java中对Thread的设计有异曲同工之处。 </p><blockquote><p>在Java中，如果我们想使用多线程，有两种办法： </p><ol><li><p>向Thread的构造函数传入一个Runnable对象，并实现Runnable的run方法 </p></li><li><p>无需向Thread的构造函数传入Runnable对象，但是要重写Thread本身的run方法 </p></li></ol></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><ul><li><p>在使用handler的时候，在handler所创建的线程需要维护一个唯一的Looper对象， 每个线程对应一个Looper，每个线程的Looper通过ThreadLocal来保证</p></li><li><p>Looper对象的内部又维护有唯一的一个MessageQueue，所以一个线程可以有多个handler，<br>但是只能有一个Looper和一个MessageQueue。</p></li><li><p>Message在MessageQueue不是通过一个列表来存储的，而是将传入的Message存入到了上一个<br>Message的next中，在取出的时候通过顶部的Message就能按放入的顺序依次取出Message。</p></li><li><p>Looper对象通过loop()方法开启了一个死循环，不断地从looper内的MessageQueue中取出Message，<br>然后通过handler将消息分发传回handler所在的线程。</p></li><li><p>handler收到消息以后，通过handleMessage进行消息处理</p></li></ul><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.25.36.png" alt="截屏2020-04-1020.25.36"></p><h2 id="6-补充：资源管理与内存泄漏"><a href="#6-补充：资源管理与内存泄漏" class="headerlink" title="6. 补充：资源管理与内存泄漏"></a>6. 补充：资源管理与内存泄漏</h2><h3 id="1-Handler的内存泄漏问题"><a href="#1-Handler的内存泄漏问题" class="headerlink" title="1. Handler的内存泄漏问题"></a>1. Handler的内存泄漏问题</h3><p>Handler使用是用来进行线程间通信的，所以新开启的线程会持有Handler引用，如果在Activity等中创建Handler，并且是非静态内部类的形式，就有可能造成内存泄漏。</p><p>首先，非静态内部类是会隐式持有外部类的引用，所以当其他线程持有了该Handler，线程没有被销毁，则意味着Activity会一直被Handler持有引用而无法导致回收。</p><p>同时，MessageQueue中如果存在未处理完的Message，Message的target也是对Activity等的持有引用，也会</p><p>造成内存泄漏。</p><p>解决的办法：</p><ul><li><p>使用静态内部类+弱引用的方式:</p><p> 静态内部类不会持有外部类的的引用，当需要引用外部类相关操作时，可以通过弱引用还获取到外部类相关操作，弱引用不会造成对象该回收回收不掉的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler sHandler = <span class="keyword">new</span> TestHandler(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> WeakReference&lt;Activity&gt; mActivity;</span><br><span class="line">    TestHandler(Activity activity) &#123;</span><br><span class="line">        mActivity = <span class="keyword">new</span> WeakReference&lt;&gt;(activity);</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.handleMessage(msg);</span><br><span class="line">    Activity activity = mActivity.get();</span><br><span class="line">    <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//<span class="doctag">TODO:</span></span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在外部类对象被销毁时，将MessageQueue中的消息清空。例如，在Activity的onDestroy时将消息清空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    handler.removeCallbacksAndMessages(<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-创建Message时的资源管理"><a href="#2-创建Message时的资源管理" class="headerlink" title="2. 创建Message时的资源管理"></a>2. 创建Message时的资源管理</h3><p>使用Handler.obtainMessage()来获取Message对象的，和直接new一个Message有什么差别呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Message message = handler.obtainMessage();</span><br><span class="line">Message message = <span class="keyword">new</span> Message();</span><br></pre></td></tr></table></figure><p>看一看obtain的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Message <span class="title">obtain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPool != <span class="keyword">null</span>) &#123;</span><br><span class="line">                Message m = sPool;</span><br><span class="line">                sPool = m.next;</span><br><span class="line">                m.next = <span class="keyword">null</span>;</span><br><span class="line">                m.flags = <span class="number">0</span>; <span class="comment">// clear in-use flag</span></span><br><span class="line">                sPoolSize--;</span><br><span class="line">                <span class="keyword">return</span> m;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Message();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在Message中有一个static Message变量sPool，这个变量是用于缓存Message对象的，在obtain中可以看到当需要一个Message对象时，如果sPool不为空则会返回当前sPool（Message），而将sPool指向了之前sPool的next对象，（之前讲MessageQueue时讲过Message的存储是以链式的形式存储的，通过Message的next指向下一个Message，这里就是返回了sPool当前这个Message，然后sPool重新指向了其下一个Message），然后将返回的Message的next指向置为空（断开链表），sPoolSize记录了当前缓存的Message的数量，如果sPool为空，则没有缓存的Message，则需要创建一个新的Message（new Message）。</p><p>那么，缓存中的sPool是哪里来的呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isInUse()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (gCheckRecycle) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"This message cannot be recycled because it "</span></span><br><span class="line">                        + <span class="string">"is still in use."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        recycleUnchecked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recycleUnchecked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Mark the message as in use while it remains in the recycled object pool.</span></span><br><span class="line">        <span class="comment">// Clear out all other details.</span></span><br><span class="line">        flags = FLAG_IN_USE;</span><br><span class="line">        what = <span class="number">0</span>;</span><br><span class="line">        arg1 = <span class="number">0</span>;</span><br><span class="line">        arg2 = <span class="number">0</span>;</span><br><span class="line">        obj = <span class="keyword">null</span>;</span><br><span class="line">        replyTo = <span class="keyword">null</span>;</span><br><span class="line">        sendingUid = -<span class="number">1</span>;</span><br><span class="line">        when = <span class="number">0</span>;</span><br><span class="line">        target = <span class="keyword">null</span>;</span><br><span class="line">        callback = <span class="keyword">null</span>;</span><br><span class="line">        data = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (sPoolSync) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sPoolSize &lt; MAX_POOL_SIZE) &#123;</span><br><span class="line">                next = sPool;</span><br><span class="line">                sPool = <span class="keyword">this</span>;</span><br><span class="line">                sPoolSize++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>recycle()是回收Message的方法,在Message处理完或者清空Message等时会调用。recycleUnchecked（）方法中可以看到，将what、arg1、arg2、object等都重置了值，如果当前sPool（Message缓存池）的大小小于允许缓存的Message最大数量时，将要回收的Message的next指向sPool，将sPool指向了回收的Message对象（即将Message放到了sPool缓存池的头部）</p><h2 id="7-参考文章"><a href="#7-参考文章" class="headerlink" title="7. 参考文章"></a>7. 参考文章</h2><p>这些是我在准备和学习过程中参考的一些博客，大家有兴趣可以自己再康康👀</p><ul><li><p>Android消息机制： <a href="https://www.jianshu.com/p/7653adc038c6" target="_blank" rel="noopener">https://www.jianshu.com/p/7653adc038c6</a></p></li><li><p>Android消息机制： <a href="https://blog.csdn.net/wsq_tomato/article/details/80301851?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/wsq_tomato/article/details/80301851?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p></li><li><p>Handler.post: <a href="https://blog.csdn.net/ly502541243/article/details/52062179?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/ly502541243/article/details/52062179?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p></li><li><p>post()和postDelay()方法精炼详解： <a href="https://blog.csdn.net/weixin_41101173/article/details/79701832" target="_blank" rel="noopener">https://blog.csdn.net/weixin_41101173/article/details/79701832</a></p></li><li><p>你真的了解Handler？： <a href="https://blog.csdn.net/qian520ao/article/details/78262289?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">https://blog.csdn.net/qian520ao/article/details/78262289?depth_1-utm_source=distribute.pc_relevant.none-task&amp;utm_source=distribute.pc_relevant.none-task</a></p></li><li><p>深入源码解析Android中的Handler,Message,MessageQueue,Looper：<a href="https://blog.csdn.net/iispring/article/details/47180325" target="_blank" rel="noopener">https://blog.csdn.net/iispring/article/details/47180325</a></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简易微信开发白皮书</title>
      <link href="/desirelife6.github.io/2019/11/03/%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%99%BD%E7%9A%AE%E4%B9%A6/"/>
      <url>/desirelife6.github.io/2019/11/03/%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%99%BD%E7%9A%AE%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h1 id="简易微信开发白皮书"><a href="#简易微信开发白皮书" class="headerlink" title="简易微信开发白皮书"></a>简易微信开发白皮书</h1><p>[TOC]</p><h2 id="1-软件概况展示"><a href="#1-软件概况展示" class="headerlink" title="1. 软件概况展示"></a>1. 软件概况展示</h2><h3 id="1-1-功能展示（截图附于文末）"><a href="#1-1-功能展示（截图附于文末）" class="headerlink" title="1.1 功能展示（截图附于文末）"></a>1.1 功能展示（截图附于文末）</h3><ul><li><h4 id="基础功能"><a href="#基础功能" class="headerlink" title="基础功能"></a>基础功能</h4></li></ul><p>1） 注册、登陆、登出(包含是否已注册、重名判断等)</p><p>2） 添加、删除好友</p><p>3） 好友列表展示</p><p>4） 实时的新消息提醒和收发消息（包含对是否好友，好友在线状态的判断）</p><p>5） 支持对文件，图片的发送和接收</p><ul><li><h4 id="拓展功能"><a href="#拓展功能" class="headerlink" title="拓展功能"></a>拓展功能</h4></li></ul><p>6） <strong>保存聊天记录</strong></p><p>7） <strong>实时弹窗提醒</strong>用户收到新消息，并<strong>展示发送方和消息预览</strong></p><p>8） 缓存聊天内容，可以<strong>保存未读的聊天记录</strong></p><p>9） 服务器主动向客户端推送信息（TCP长连接，<strong>模拟实现双工通信</strong>）</p><p>10） 使用<strong><code>token</code>进行用户身份验证</strong>，除密码验证外提供多一层的安全保障</p><p>11） UI美化，<strong>消息气泡大小动态变化</strong></p><p>12） 展示用户信息，如用户名，头像等</p><h3 id="1-2-健壮性及异常情况处理展示"><a href="#1-2-健壮性及异常情况处理展示" class="headerlink" title="1.2 健壮性及异常情况处理展示"></a>1.2 健壮性及异常情况处理展示</h3><p>1） 检测并阻止重复注册或登陆</p><p>2） 检测用户的在线状态</p><p>3） 检查用户的好友列表及好友关系</p><h2 id="2-软件整体系统架构分析"><a href="#2-软件整体系统架构分析" class="headerlink" title="2. 软件整体系统架构分析"></a>2. 软件整体系统架构分析</h2><h3 id="2-1-整体：前后端分离"><a href="#2-1-整体：前后端分离" class="headerlink" title="2.1 整体：前后端分离"></a>2.1 整体：前后端分离</h3><ul><li>简易微信整体<strong>前后端分离</strong></li><li>服务器的开发语言为 java，开发工具为 intelliJ Idea；</li><li>客户端的开发语言为 kotlin， 开发工具为 Android Studio。 </li><li>服务器部署在本机，与各客户端采用socket连接，C/S模式。UML图如下：</li></ul><h3 id="2-2-服务器端：JDBC-Socket-Thread-PostgreSql"><a href="#2-2-服务器端：JDBC-Socket-Thread-PostgreSql" class="headerlink" title="2.2 服务器端：JDBC, Socket, Thread, PostgreSql"></a>2.2 服务器端：JDBC, Socket, Thread, PostgreSql</h3><ul><li>采用<code>JDBC</code>管理底层数据库，底层采用<code>postgreSql</code>数据库存储必要的信息</li><li>使用 java结合sql语句操作数据库，实现对信息的增删查改。</li><li>采用<code>Socket</code>连接实现与客户端的连接与通信，从而成为沟通客户端的中枢，典型的C/S。</li><li>采用多线程开启socket通信，使用统一的Server和Map进行管理</li><li>重写java的Tuple类，以实现服务器的多返回值</li></ul><h3 id="2-3-客户端：MVP、Fragment、Json"><a href="#2-3-客户端：MVP、Fragment、Json" class="headerlink" title="2.3 客户端：MVP、Fragment、Json"></a>2.3 客户端：MVP、Fragment、Json</h3><ul><li>使用 kotlin开发，MVP技术架构。数据层(model)、数据处理层(presenter)、用户交互层(view)高度解耦，使得数据处理和用户交互更加优雅</li><li>主界面采用ViewPager+Fragment，可以轻松在各界面间滑动</li><li>每项操作都提供反馈，实时接收服务器消息</li><li>自定数据、协议格式，借鉴目前常用的Json格式</li><li>快速、稳定的图片传输</li></ul><h2 id="3-自定义协议分析"><a href="#3-自定义协议分析" class="headerlink" title="3. 自定义协议分析"></a>3. 自定义协议分析</h2><h3 id="3-1-传输协议及格式"><a href="#3-1-传输协议及格式" class="headerlink" title="3.1 传输协议及格式"></a>3.1 传输协议及格式</h3><p>简易微信server端采用TCP作为传输层协议，http作为应用层协议，并对http的协议格式和报文格式进行自定义修改，报文采用 json 格式数据文档实现server与client间的通信。</p><h3 id="3-2-网络连接"><a href="#3-2-网络连接" class="headerlink" title="3.2 网络连接"></a>3.2 网络连接</h3><ul><li>服务器搭建在本地，监听12000端口，本机访问服务器使用 ip为127.0.0.1，其余客户端访问服务器时地址采用本机 ip。服务器程序会一直监听发起请求的客户端，与之保持连接状态，直到客户<br>端主动断开连接。在此期间，服务器与客户端间的输入输出流将保持。需要注意的是，每次服务器重启会强制登出所有用户。 </li><li>服务器可以接受并处理post请求，以json格式的数据返回请求结果及信息</li></ul><h3 id="3-3-部分自定义协议的接口文档（完整版太多了，附于文档末尾）"><a href="#3-3-部分自定义协议的接口文档（完整版太多了，附于文档末尾）" class="headerlink" title="3.3 部分自定义协议的接口文档（完整版太多了，附于文档末尾）"></a>3.3 部分自定义协议的接口文档（完整版太多了，附于文档末尾）</h3><h4 id="1-返回报文的body组成"><a href="#1-返回报文的body组成" class="headerlink" title="1. 返回报文的body组成"></a>1. 返回报文的body组成</h4><p>每次服务器返回的报文body都会包含以下信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:code,  “msg”:”msg”,  “type”:”type” &#125;</span><br></pre></td></tr></table></figure><p>其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类</p><h4 id="2-用户注册"><a href="#2-用户注册" class="headerlink" title="2. 用户注册"></a>2. 用户注册</h4><p>接口路径为 <code>ip/register</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回报文的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”register” &#125;</span><br></pre></td></tr></table></figure><p>返回的code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">注册成功</td></tr><tr><td align="center">-1</td><td align="center">重复的用户名</td></tr></tbody></table><h4 id="3-用户登陆"><a href="#3-用户登陆" class="headerlink" title="3. 用户登陆"></a>3. 用户登陆</h4><p>接口路径为<code>ip/login</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”login”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">密码错误</td></tr><tr><td align="center">2</td><td align="center">已经在线了</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr></tbody></table><h4 id="4-用户登出"><a href="#4-用户登出" class="headerlink" title="4. 用户登出"></a>4. 用户登出</h4><p>路径<code>ip/logout</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “userName”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” offline” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">已经离线了</td></tr><tr><td align="center">2</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户不存在</td></tr></tbody></table><h4 id="5-获取好友列表"><a href="#5-获取好友列表" class="headerlink" title="5. 获取好友列表"></a>5. 获取好友列表</h4><p>路径<code>ip/friends</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friends”,  “friends”:[“friend1”,”friend2”] &#125; </span><br><span class="line">-- friends是一个jsonArray的数组</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr></tbody></table><h4 id="6-完整版自定义协议的接口文档附于本文档末尾"><a href="#6-完整版自定义协议的接口文档附于本文档末尾" class="headerlink" title="6. 完整版自定义协议的接口文档附于本文档末尾"></a>6. 完整版自定义协议的接口文档附于本文档末尾</h4><h2 id="3-各部分实现技术细节分析"><a href="#3-各部分实现技术细节分析" class="headerlink" title="3. 各部分实现技术细节分析"></a>3. 各部分实现技术细节分析</h2><h3 id="3-1-服务器技术细节"><a href="#3-1-服务器技术细节" class="headerlink" title="3.1 服务器技术细节"></a>3.1 服务器技术细节</h3><h4 id="3-1-1-DataBeans-包"><a href="#3-1-1-DataBeans-包" class="headerlink" title="3.1.1 DataBeans 包"></a>3.1.1 <strong><code>DataBeans</code></strong> 包</h4><ul><li>该包下存放登录、注册等各种不同请求的数据类，统一命名为<strong><code>XxxRequestBean</code></strong>,<strong><code>XxxResponseBean</code></strong>,如（<code>CommonRequestBean</code>, <code>CommonResponseBean</code>等）</li><li><strong><code>XxxRequestBean</code></strong>用于存储从请求报文中按格式解析出的信息，用于本地对数据库的操作</li><li><strong><code>XxxResponseBean</code></strong>用于存储本地对数据库增删查改后的结果，用于向发起请求的客户端返回信息以及向需要转发的客户端转发消息</li><li>值得一提的是在该包内抽象出了<strong><code>JsonToObject</code></strong>和<strong><code>ObjectToJson</code></strong>两个接口，实现通信报文中json格式数据与服务器中java对象类型数据的项目转化，提高了代码复用性和可读性。</li></ul><h4 id="3-1-2-HttpServer-java"><a href="#3-1-2-HttpServer-java" class="headerlink" title="3.1.2 HttpServer.java"></a>3.1.2 <strong><code>HttpServer.java</code></strong></h4><ul><li>该类持有server服务器的对象，并持有<code>userMap</code>等数据结构保存用户的<code>id</code>和对应的<code>socket</code>通信，从而实现<strong>服务器向特定用户主动推送消息</strong>，实现<strong>好友申请和收到消息的即时提醒</strong></li><li>在此类使用多线程处理每个独立的socket通信，避免相互之间的干扰，便于管理，也能实现多用户登录</li><li>此类中的<strong><code>initDataBase</code></strong>方法使用JDBC连接数据库，若是数据库不存在时则主动建立数据库，具有良好的健壮性</li></ul><h4 id="3-1-3-ServerThread-java"><a href="#3-1-3-ServerThread-java" class="headerlink" title="3.1.3 ServerThread.java"></a>3.1.3 <strong><code>ServerThread.java</code></strong></h4><ul><li>该类定义每个独立的线程中socket通信的动作，其中包括：</li><li><ul><li>重载<strong><code>Thread</code></strong>的<strong><code>run</code></strong>方法<strong>解析自定义的请求报文</strong>，得到请求种类（如<code>GET</code>）和请求的<code>url</code>以及请求报文<code>body</code>，传递给<strong><code>post</code></strong>函数</li><li><strong><code>post</code></strong>函数得到报文，根据<code>header</code>中的url对各个功能函数进行调用，进行相应处理后得到应返回的数据。并通过各<code>Bean</code>类的格式化函数将信息格式化为合法的报文进行返回</li><li>使用<strong><code>response</code>返回发出请求的客户端</strong>，使用<strong><code>sendInfos</code>向被请求的客户端主动推送消息</strong></li><li><code>regist</code>， <code>login</code>等功能函数从报文的<code>body</code>中得到用户名，身份验证<code>token</code>等信息，用于实现简易微信的各项功能，如：</li><li><ul><li><code>registe</code> 从报文中获得用户名和密码，在数据库中进行查询，进行注册或返回异常（如重复用户名）等操作</li><li><code>login</code> ，<code>logout</code>时对身份<code>token</code>进行验证后，更新数据库并返回用户的请求状态，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息</li><li><code>getFriends</code>时，根据用户名查询数据库，进行数据更新并返回好友列表</li><li>发送消息时，客户端请求<code>sendMsg</code>，向服务器发出消息及接收方和发送时间；服务器接到该报文后解析出被发送方，然后通过<strong><code>sendToFriend</code></strong>查询数据库得到被发送方的信息是否合法，该用户是否在线等，并通过<code>Map</code>得到该用户对应的socket连接。若是均符合条件，调用<strong><code>sendTo</code></strong>对消息进行转发，主动发给消息接收方</li><li>发送图片和文件类型的消息流程基本一致，函数分别为<code>sendPicsToFriend</code>, <code>sendPics</code>和<code>sendFileToFriends</code>, <code>sendFile</code></li><li>添加好友与发送消息时类似，用户将请求发送给服务器，然后由服务器通过被请求方对应的socket连接进行转发。其中<code>makeFriends</code>进行数据库查询判断信息是否合法，并得到被请求方对应的socket连接，然后使用<code>sendFriendRequest</code>由服务器主动向被请求方转发好友请求</li><li>发送好友申请的结果流程与申请添加好友一致，函数为<code>makeFriendsCheck</code>和<code>sendResquestRes</code></li><li>删除好友<code>deleteFriend</code>时，用户向服务器发出请求，服务器通过<code>deleteFriend</code>处理数据库中的好友关系表，实现对数据的更新，并返回给用户操作状态</li><li>发送图片和文件时，使用Socket的文件输入输出流<code>FileInputStream</code>和<code>FileOutputStream</code>，进行字节流传输，以二进制流的方式进行传输</li></ul></li></ul></li></ul><h4 id="3-1-4-Tuple-java"><a href="#3-1-4-Tuple-java" class="headerlink" title="3.1.4 Tuple.java"></a>3.1.4 <strong><code>Tuple.java</code></strong></h4><ul><li>重写java的Tuple类，以实现服务器某些功能函数要求的多返回值情况</li></ul><h3 id="3-2-客户端技术细节"><a href="#3-2-客户端技术细节" class="headerlink" title="3.2 客户端技术细节"></a>3.2 客户端技术细节</h3><h4 id="3-2-1NetService-kt"><a href="#3-2-1NetService-kt" class="headerlink" title="3.2.1NetService.kt"></a>3.2.1<strong><code>NetService.kt</code></strong></h4><ul><li>该包下存放登录、注册等各种不同请求方法，和存放<strong><code>socket</code></strong></li><li>该文件下存放所有网络请求相关的方法，其中包括<ul><li><strong><code>loginService</code></strong>，进行登录请求同时接收服务器的回复，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息</li><li><strong><code>logoutService</code></strong>登出请求同时接收服务器的回复</li><li><strong><code>regiService</code></strong>注册请求同时接收服务器的回复</li><li><strong><code>friendsService</code></strong>接收好友列表同时接收服务器的回复</li><li><strong><code>deleteService</code></strong>删除好友同时接收服务器的回复</li><li><strong><code>makefriendsService</code></strong>添加好友同时接收服务器的回复</li><li><strong><code>confirmRequestService</code></strong>确认好友信息同时接收服务器的回复</li><li><strong><code>sendPictureService</code></strong>发送照片同时接收服务器的回复</li><li><strong><code>sendMessageService</code></strong>发送消息同时接收服务器的回答</li></ul></li></ul><h4 id="3-2-2-LoginBean-kt"><a href="#3-2-2-LoginBean-kt" class="headerlink" title="3.2.2 LoginBean.kt"></a>3.2.2 <code>LoginBean.kt</code></h4><ul><li>在该包下保存用于保存服务器请求的数据类</li><li>命名统一为<code>XXBean</code></li></ul><h4 id="3-2-3Items-kt"><a href="#3-2-3Items-kt" class="headerlink" title="3.2.3Items.kt"></a>3.2.3<code>Items.kt</code></h4><ul><li>在该包下保存<code>RecyclerView</code>解耦之后的各种<code>item</code></li><li>使用<code>RecyclerDSL</code></li></ul><h4 id="3-2-4UISupport-kt"><a href="#3-2-4UISupport-kt" class="headerlink" title="3.2.4UISupport.kt"></a>3.2.4<code>UISupport.kt</code></h4><ul><li>用于制作<strong>沉浸式状态栏</strong></li></ul><h4 id="3-2-5TabFragment"><a href="#3-2-5TabFragment" class="headerlink" title="3.2.5TabFragment"></a>3.2.5<code>TabFragment</code></h4><ul><li>提供了管理三个页面的三个方法：<ul><li>管理聊天界面：<code>setTalkList</code></li><li>管理好友界面：<code>setFriendList</code></li><li>管理设置：<code>setMineList</code></li></ul></li></ul><h4 id="3-2-6ItemAdapter"><a href="#3-2-6ItemAdapter" class="headerlink" title="3.2.6ItemAdapter"></a>3.2.6<code>ItemAdapter</code></h4><ul><li>用于管理聊天界面的<code>RecyclerView</code>的消息展示</li><li>通过<code>addItem</code>方法直接添加子项</li></ul><h4 id="3-2-7LoginActivity"><a href="#3-2-7LoginActivity" class="headerlink" title="3.2.7LoginActivity"></a>3.2.7<code>LoginActivity</code></h4><ul><li>登陆界面，监听两个<code>EditText</code>和一个<code>LoginButton</code></li></ul><h4 id="3-2-8MainActivity"><a href="#3-2-8MainActivity" class="headerlink" title="3.2.8MainActivity"></a>3.2.8<code>MainActivity</code></h4><ul><li>应用的总界面，有三个<code>Fragment</code>，分别为消息列表，好友列表和个人信息</li><li>使用<code>Handler</code>进行回调，进行线程间通信</li><li>外层是<code>Viewpager</code>，可以轻松实现页面间滑动</li></ul><h4 id="3-2-9TalkActivity"><a href="#3-2-9TalkActivity" class="headerlink" title="3.2.9TalkActivity"></a>3.2.9<code>TalkActivity</code></h4><ul><li>聊天界面</li><li>点九图实现气泡</li><li>使用<code>Handler</code>进行回调</li><li>可以发送消息、图片、文件</li><li>增加文件选择器，可从本地选择文件</li></ul><h4 id="3-2-10-MVP架构"><a href="#3-2-10-MVP架构" class="headerlink" title="3.2.10 MVP架构"></a>3.2.10 <code>MVP架构</code></h4><ul><li>对数据层（Model）、处理层（Presenter）和交互层（View）进行解耦</li><li>便于维护和根据特定需求进行修改</li></ul><h3 id="3-3-数据库技术细节"><a href="#3-3-数据库技术细节" class="headerlink" title="3.3 数据库技术细节"></a>3.3 数据库技术细节</h3><p>数据库中采用sql语句建立两个表，分别存储用户信息及用户好友关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> UserData(</span><br><span class="line">    userName <span class="built_in">VARCHAR</span> PRIMARY <span class="keyword">KEY</span>,<span class="comment">--用户名，作为主键</span></span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INTEGER</span>,<span class="comment">--用户id</span></span><br><span class="line">    <span class="keyword">passWord</span> <span class="built_in">VARCHAR</span>,<span class="comment">--密码</span></span><br><span class="line">    isOnline <span class="built_in">INTEGER</span>,<span class="comment">--用户在线状态</span></span><br><span class="line">    token <span class="built_in">INTEGER</span>);<span class="comment">--用于身份验证的token</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> UserFriends(</span><br><span class="line">    userName <span class="built_in">VARCHAR</span>,<span class="comment">--用户名</span></span><br><span class="line">    friendName <span class="built_in">VARCHAR</span>,<span class="comment">--用户的好友名</span></span><br><span class="line">    <span class="keyword">ID</span> <span class="built_in">INTEGER</span> PRIMARY <span class="keyword">KEY</span>);<span class="comment">--用户id</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">-- 主键的意义在于快速检索每个用户对应的socket</span></span><br></pre></td></tr></table></figure><p>其中userName存储用户名， ID作为与每个用户对应的Socket通信的标识，isOnline存储用户的在线离线状态，便于服务器在收到消息和好友申请时的判断和处理。</p><h2 id="4-难点重点回顾-以下代码均为示意，并非源代码"><a href="#4-难点重点回顾-以下代码均为示意，并非源代码" class="headerlink" title="4. 难点重点回顾(以下代码均为示意，并非源代码)"></a>4. 难点重点回顾(以下代码均为示意，并非源代码)</h2><h3 id="4-1-服务器端"><a href="#4-1-服务器端" class="headerlink" title="4.1 服务器端"></a>4.1 服务器端</h3><ul><li>最早时未使用统一的<code>Server</code>和 <code>clientMap</code>管理Socket连接，导致各个用户的连接之间出现数据相互影响的情况，后通过引入多线程处理消息和Map统一管理来解决这一问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Integer, Socket&gt; userMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    client = <span class="keyword">this</span>.server.accept();</span><br><span class="line">    <span class="keyword">new</span> Thread(<span class="keyword">new</span> ServerThread(client)).start();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于TCP短连接的问题，导致连接不稳定，经常意外中断，后通过持续监听的心跳机制实现TCP长连接解决了该问题</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line"><span class="keyword">assert</span> server != <span class="keyword">null</span>;</span><br><span class="line">    client = <span class="keyword">this</span>.server.accept();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>转发消息时经常误判需要被发送的socket并出现<code>wirterror</code>，后来通过封装为函数，通过传参的方式确定socket和报文格式解决</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">String commonMSG = <span class="string">"HTTP/1.1 %code %msg\r\n"</span> +</span><br><span class="line"><span class="string">"Content-Type: application/json;charset=utf-8\r\n"</span> +</span><br><span class="line">                        <span class="string">"Connection: keep-alive\r\n"</span> +</span><br><span class="line">                        <span class="string">"Content-Length: %type_body\r\n\r\n"</span>;</span><br><span class="line">                        </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendInfos</span><span class="params">(Socket infoClient, String json)</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">String res = json + <span class="string">"\n"</span>;</span><br><span class="line">        OutputStream out = client.getOutputStream();</span><br><span class="line">        out.write(res.getBytes());</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-完整版接口文档"><a href="#5-完整版接口文档" class="headerlink" title="5. 完整版接口文档"></a>5. 完整版接口文档</h2><h4 id="1-返回报文的body组成-1"><a href="#1-返回报文的body组成-1" class="headerlink" title="1. 返回报文的body组成"></a>1. 返回报文的body组成</h4><p>每次服务器返回的报文body都会包含以下信息：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:code,  “msg”:”msg”,  “type”:”type” &#125;</span><br></pre></td></tr></table></figure><p>其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类</p><h4 id="2-用户注册-1"><a href="#2-用户注册-1" class="headerlink" title="2. 用户注册"></a>2. 用户注册</h4><p>接口路径为 <code>ip/register</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回报文的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”register” &#125;</span><br></pre></td></tr></table></figure><p>返回的code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">注册成功</td></tr><tr><td align="center">-1</td><td align="center">重复的用户名</td></tr></tbody></table><h4 id="3-用户登陆-1"><a href="#3-用户登陆-1" class="headerlink" title="3. 用户登陆"></a>3. 用户登陆</h4><p>接口路径为<code>ip/login</code></p><p>请求报文的body格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “pwd”:”password” &#125;</span><br></pre></td></tr></table></figure><p>返回的body格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:”login”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">密码错误</td></tr><tr><td align="center">2</td><td align="center">已经在线了</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr></tbody></table><h4 id="4-用户登出-1"><a href="#4-用户登出-1" class="headerlink" title="4. 用户登出"></a>4. 用户登出</h4><p>路径<code>ip/logout</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “userName”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” offline” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">已经离线了</td></tr><tr><td align="center">2</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户不存在</td></tr></tbody></table><h4 id="5-获取好友列表-1"><a href="#5-获取好友列表-1" class="headerlink" title="5. 获取好友列表"></a>5. 获取好友列表</h4><p>路径<code>ip/friends</code></p><p>请求报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345 &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friends”,  “friends”:[“friend1”,”friend2”] &#125; </span><br><span class="line">-- friends是一个jsonArray的数组</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">OK</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr></tbody></table><h4 id="6-发送加好友请求"><a href="#6-发送加好友请求" class="headerlink" title="6. 发送加好友请求"></a>6. 发送加好友请求</h4><p>路径<code>ip/makefriends</code></p><p>请求报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345,  “newfriend”:”newfriend” &#125;</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” makefriend”, &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">请求发送成功</td></tr><tr><td align="center">1</td><td align="center">token 无效</td></tr><tr><td align="center">2</td><td align="center">已经是好友了</td></tr><tr><td align="center">3</td><td align="center">目标用户不存在</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">目标用户不在线</td></tr></tbody></table><p>请求只有在对方在线时在允许发送</p><h4 id="7-回复好友请求"><a href="#7-回复好友请求" class="headerlink" title="7. 回复好友请求"></a>7. 回复好友请求</h4><p>路径<code>ip/result</code></p><p>请求报文：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “from”:”A”,  “to”:”B”,  “token”:12345,  “status”:1 &#125;</span><br><span class="line">-- from 代表当前用户的用户名</span><br><span class="line">-- to 代表接受方的用户名</span><br><span class="line">-- status 代表回复的结果</span><br><span class="line">-- token用于身份验证，保证安全性</span><br></pre></td></tr></table></figure><p>返回报文：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; “code”:0,  “msg”:”msg”,  “type”:” result” &#125;</span><br></pre></td></tr></table></figure><p>code及msg;</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">已经是好友了</td></tr><tr><td align="center">3</td><td align="center">目标用户不存在</td></tr><tr><td align="center">-1</td><td align="center">用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">目标用户不在线</td></tr></tbody></table><h4 id="8-服务器端转发好友请求"><a href="#8-服务器端转发好友请求" class="headerlink" title="8. 服务器端转发好友请求"></a>8. 服务器端转发好友请求</h4><p>报文格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” friendrequest”, “from”:”from” &#125;</span><br></pre></td></tr></table></figure><p>服务器收到用户发出的好友申请时，会主动向被申请方发出该消息</p><h4 id="9-服务器端转发好友请求的回复结果"><a href="#9-服务器端转发好友请求的回复结果" class="headerlink" title="9. 服务器端转发好友请求的回复结果"></a>9. 服务器端转发好友请求的回复结果</h4><p>报文格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” makefriendres” &#125;</span><br></pre></td></tr></table></figure><p>服务器收到被申请方的回复时，会主动向申请方发出该消息</p><h4 id="10-发送消息"><a href="#10-发送消息" class="headerlink" title="10. 发送消息"></a>10. 发送消息</h4><p>路径<code>ip/sendmsg</code></p><p>报文格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345, “to”:”to”, “msg”:”data” , "time":"time"&#125;</span><br></pre></td></tr></table></figure><p>返回格式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” sendmsgres” &#125;</span><br></pre></td></tr></table></figure><p>code及msg：</p><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">发送成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">没有这个好友</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">当前用户不在线</td></tr></tbody></table><h4 id="11-服务器转发消息"><a href="#11-服务器转发消息" class="headerlink" title="11. 服务器转发消息"></a>11. 服务器转发消息</h4><p>报文格式：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "time":"time"&#125;</span><br></pre></td></tr></table></figure><p>当服务器收到客户端发送的消息时，该 json 由服务器主动发出。其中 code 总是 0，from 表示<br>发送方用户名，msg 为消息本体。 </p><h4 id="12-发送文件"><a href="#12-发送文件" class="headerlink" title="12. 发送文件"></a>12. 发送文件</h4><p>路径<code>ip/sendFile</code></p><p>报文格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "to": "to", "time":"time"， "filename": "filename"&#125;  </span><br><span class="line">- msg 发送文件转码的字节流</span><br><span class="line">- filename 发送文件名</span><br></pre></td></tr></table></figure><p>返回格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” sendfile” &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">发送成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr><tr><td align="center">2</td><td align="center">没有这个好友</td></tr><tr><td align="center">-1</td><td align="center">该用户尚未注册</td></tr><tr><td align="center">-2</td><td align="center">当前用户不在线</td></tr></tbody></table><h4 id="13-服务器主动转发文件"><a href="#13-服务器主动转发文件" class="headerlink" title="13. 服务器主动转发文件"></a>13. 服务器主动转发文件</h4><p>发送报文</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” msg”, “from”:”from” , "time":"time", "filename": "filename"&#125;  </span><br><span class="line">- msg 发送文件转码的字节流</span><br><span class="line">- filename 发送文件名</span><br></pre></td></tr></table></figure><h4 id="14-删除好友"><a href="#14-删除好友" class="headerlink" title="14. 删除好友"></a>14. 删除好友</h4><p>路径<code>ip/delete</code></p><p>报文格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “username”:”name”,  “token”:12345,  “friendname”:”friendname” &#125;</span><br></pre></td></tr></table></figure><p>返回格式</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;  “code”:0,  “msg”:”msg”,  “type”:” delete” &#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">code</th><th align="center">msg</th></tr></thead><tbody><tr><td align="center">0</td><td align="center">删除成功</td></tr><tr><td align="center">1</td><td align="center">token无效</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初始卷积神经网络（CNN）</title>
      <link href="/desirelife6.github.io/2019/09/02/%E5%88%9D%E8%AF%86%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89/"/>
      <url>/desirelife6.github.io/2019/09/02/%E5%88%9D%E8%AF%86%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基础结构"><a href="#一、基础结构" class="headerlink" title="一、基础结构"></a>一、基础结构</h2><p>CNN和之前介绍的神经网络一样，可以像乐高积木一样通过组装层来构建。不过， CNN中新出现了卷积层（Convolution层）和池化层（Pooling层）。此外，各层中传递的数据是有形状的数据（比如，3维数据）</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.12.42.png" alt="截屏2020-04-1020.12.42"></p><p>靠近输出的层中使用了之前 的“ Affine - ReLU”组合。此外，最后的输出层中使用了之前的“Affine - Softmax”组合。这些都是一般的CNN中比较常见的结构。</p><h2 id="二、卷积层"><a href="#二、卷积层" class="headerlink" title="二、卷积层"></a>二、卷积层</h2><h3 id="2-1-卷积层的优势"><a href="#2-1-卷积层的优势" class="headerlink" title="2.1 卷积层的优势"></a>2.1 卷积层的优势</h3><p>在全连接层中，数据的形状被忽视了。以图像输入为例子，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。前面提到的使用 了MNIST数据集的例子中，输入图像就是1通道、高28像素、长28像素的（1, 28, 28）形状，但却被排成1列，以784个数据的形式输入到最开始的 Affine层。<br>而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此可以提取出邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距 较远的像素之间没有什么关联等值得提取的本质模式，利用与数据形状相关的信息。</p><h3 id="2-2-卷积运算（图像处理中的滤波器运算）"><a href="#2-2-卷积运算（图像处理中的滤波器运算）" class="headerlink" title="2.2 卷积运算（图像处理中的滤波器运算）"></a>2.2 卷积运算（图像处理中的滤波器运算）</h3><h4 id="2-2-1-卷积运算基本过程"><a href="#2-2-1-卷积运算基本过程" class="headerlink" title="2.2.1 卷积运算基本过程"></a>2.2.1 卷积运算基本过程</h4><p>先来看一个经过卷积运算的结果</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.14.11.png" alt="截屏2020-04-1020.14.11"></p><p>对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指下图中灰色的3×3的部分。如下图所示，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。然后，将这个结果保存到输出的对应位置。将这个过程在所有位置都进行一遍，就可以得到卷积运算的输出。 如果有偏置，则在卷积运算结果的各个位置都加上偏置的值。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.14.25.png" alt="截屏2020-04-1020.14.25"></p><h4 id="2-2-2-填充"><a href="#2-2-2-填充" class="headerlink" title="2.2.2 填充"></a>2.2.2 填充</h4><p>在卷积神经网络中引入了填充和步幅等特殊概念，这里我们来介绍一下填充。<br>在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding），是卷积运算中经常会用到的处理。比如， 在下图的例子中，对大小为(4, 4)的输入数据应用了幅度为1的填充。“幅度为1的填充”是指用幅度为1像素的0填充周围。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.14.38.png" alt="截屏2020-04-1020.14.38"></p><p>可以看到，通过填充，大小为(4, 4)的输入数据变成了(6,6)的形状。 然后，应用大小为(3, 3)的滤波器，生成了大小为(4,4)的输出数据。这个例子中将填充的值设成了1，不过填充的值也可以设置成2、3等任意的整数。在图该例子中，如果将填充设为2，则输入数据的大小变为(8,8)；如果将填充设 为3，则大小变为(10, 10)。</p><blockquote><p>使用填充主要是为了调整输出的大小。比如，对大小为(4, 4)的输入数据应用(3,3)的滤波器时，输出大小变为(2, 2)，相当于输出大小比输入大小缩小了2个元素。在反复进行多次卷积运算的深度网络中,如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能变为1，导致无法再应用卷积运算。</p></blockquote><h4 id="2-2-3-步幅"><a href="#2-2-3-步幅" class="headerlink" title="2.2.3 步幅"></a>2.2.3 步幅</h4><p>介绍完填充，再来介绍一下步幅。步幅是应用滤波器的位置间隔，以下是步幅为2的情况。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.15.18.png" alt="截屏2020-04-1020.15.18"></p><h4 id="2-2-4-填充，步幅和输出结果的关系"><a href="#2-2-4-填充，步幅和输出结果的关系" class="headerlink" title="2.2.4 填充，步幅和输出结果的关系"></a>2.2.4 填充，步幅和输出结果的关系</h4><p>增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。 如果将这样的关系写成算式，会如何呢？<br>我们看一下对于填充和步幅，如何计算输出大小。 这里，假设输入大小为(H,W)，滤波器大小为(FH,FW)，输出大小为 (OH,OW)，填充为P，步幅为S。此时，输出大小可通过下列式子计算。</p><hr><p>$$ OH = \frac{H+2P-FH}{S} + 1 $$</p><p>$$ OW = \frac{H+2P-FW}{S} + 1 $$</p><hr><p><strong>我们来思考一个问题，为什么卷积运算是有效的？</strong><br>依然用例子来说明，比如我们有一个4*4的图像，我们设计两个卷积核，看看运用卷积核后图片会变成什么样。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.15.29.png" alt="截屏2020-04-1020.15.29"></p><p>从结果可以看出，通过第一个卷积核计算后的特征图是一个三维数据，在第三列的绝对值最大，说明原始图片上对应的地方有一条垂直方向的特征，即像素数值变化较大；<br>而通过第二个卷积核计算后，第三列的数值为0，第二行的数值绝对值最大，说明原始图片上对应的地方有一条水平方向的特征，即像素值数值变化较大。<br>这样就提取出了大致的两个特征，通过在更深层次的网络中设置更多更巧妙的卷积核，我们就可以得到更多更准确的特征。<br>我们设计的卷积核分别能够提取，或者说检测出原始图片的特定的特征。所以实际上就可以把卷积核理解为特征提取器，我们不需要手动去选取特征，只用设计好卷积核的尺寸，数量和滑动的步长就可以让它自己去训练了。同时，由于多个神经元可以共享卷积核，对于高位数据的处理将会变得非常简单。<br>留下几个小问题供大家思考：</p><p>1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？</p><p>2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ </p><p>3.步长的向右和向下移动的幅度必须是一样的吗？</p><p>在最后我将给出这些问题的答案。</p><h4 id="2-2-5-多通道图的卷积运算"><a href="#2-2-5-多通道图的卷积运算" class="headerlink" title="2.2.5 多通道图的卷积运算"></a>2.2.5 多通道图的卷积运算</h4><p>这里先介绍单通道图和多通道图的概念<br>（一）：单通道图<br>俗称灰度图，每个像素点只能有有一个值表示颜色，它的像素值在0到255之间，0是黑色，255是白色，中间值是一些不同等级的灰色。（也有3通道的灰度图，3通道灰度图只有一个通道有值，其他两个通道的值都是零）。<br>（二）:三通道图<br>每个像素点都有3个值表示 ，所以就是3通道。也有4通道的图。例如RGB图片即为三通道图片，RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。总之，每一个点由三个值表示。</p><p>之前的卷积运算的例子都是以有高、长方向的2维形状的单通道图为对象的。<br>但是， 图像是3维数据，除了高、长方向之外，还需要处理通道方向。这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。这里以3通道的数据为例， 展示了卷积运算的结果。和2维数据时相比，可以发现纵深方向（通道方向）上特征图增加了。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.15.48.png" alt="截屏2020-04-1020.15.48"></p><p>需要注意的是，在3维数据的卷积运算中，输入数据和滤波器的通道数要设为相同的值。从上图可知，每个卷积核输出一张特征图，而多个卷积核输出的特征图汇集在一起，传递给下一层，这就是CNN的处理流。<br>最后再看看一看卷积运算中的处理流是什么亚子。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.15.58.png" alt="截屏2020-04-1020.15.58"></p><h2 id="三、-池化"><a href="#三、-池化" class="headerlink" title="三、 池化"></a>三、 池化</h2><p>讲了这么久的卷积，终于来到了池化（pooling）层<br>池化是缩小高、长方向上的空间的运算。比如，如图所示，进行将 2×2的区域集约成1个元素的处理，缩小空间大小。一般来说，池化的窗口大小会 和步幅设定成相同的值。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.16.15.png" alt="截屏2020-04-1020.16.15"></p><blockquote><p>除了MaxPooling之外，还有AveragePooling等。相对于MaxPooling是从目标区域中取出最大值，AveragePooling则是计算目标区域的平均值。 在图像识别领域，主要使用MaxPooling。</p></blockquote><p><strong>那么问题来了，为什么MaxPooling能起到效果呢</strong><br>MaxPooling意义在哪里？如果我们只取最大值，那其他的值被舍弃难道就没有影响吗？不会损失这部分信息吗？如果认为这些信息是可损失的，那么是否意味着我们在进行卷积操作后仍然产生了一些不必要的冗余信息呢？</p><p>其实从上文分析卷积核为什么有效的原因来看，每一个卷积核可以看做一个特征提取器，不同的卷积核负责提取不同的特征，我们例子中设计的第一个卷积核能够提取出“垂直”方向的特征，第二个卷积核能够提取出“水平”方向的特征，那么我们对其进行MaxPooling操作后，提取出的是真正能够识别特征的数值，其余被舍弃的数值，对于我提取特定的特征并没有特别大的帮助。<br>在进行后续计算时，就减小了特征图的尺寸，从而减少参数，达到减小计算量，缺不损失效果的情况。</p><p>这也意味着MaxPooling对微小的位置变化具有健壮性，输入数据发生微小偏差时，池化仍会返回相同的结果,池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。</p><p>不过并不是所有情况MaxPooling的效果都很好，有时候有些周边信息也会对某个特定特征的识别产生一定效果，那么这个时候舍弃这部分“不重要”的信息，就不划算了。所以还要具体情况具体分析，如果加了Max Pooling后效果反而变差了，不如把卷积后不加MaxPooling的结果与卷积后加了MaxPooling的结果输出对比一下，看看MaxPooling是否对卷积核提取特征起了反效果。</p><h4 id="3-1-Flatten层-amp-Fully-Connected-Layer"><a href="#3-1-Flatten层-amp-Fully-Connected-Layer" class="headerlink" title="3.1 Flatten层 &amp; Fully Connected Layer"></a>3.1 Flatten层 &amp; Fully Connected Layer</h4><p>　　到这一步，其实我们的一个完整的“卷积部分”就算完成了，如果想要叠加层数，一般也是叠加“Conv-MaxPooing”,通过不断的设计卷积核的尺寸，数量，提取更多的特征，最后识别不同类别的物体。做完MaxPooling后，我们就会把这些数据“拍平”，丢到Flatten层，然后把Flatten层的output放到full connected Layer里，采用softmax对其进行分类。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.16.26.png" alt="截屏2020-04-1020.16.26"></p><h2 id="四、-CNN的可视化"><a href="#四、-CNN的可视化" class="headerlink" title="四、 CNN的可视化"></a>四、 CNN的可视化</h2><p>学习前的滤波器是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。我们发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.16.36.png" alt="截屏2020-04-1020.16.36"></p><p>如果要问右边的有规律的滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。比如，左半部分为白色、右半部分为黑色的滤波器的情况下，如图所示，会对垂直方向上的边缘有响应。<br><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.16.46.png" alt="截屏2020-04-1020.16.46"></p><h2 id="五、问题小结"><a href="#五、问题小结" class="headerlink" title="五、问题小结"></a>五、问题小结</h2><p>最后是上面给大家留下的问题<br>1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？</p><p>2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ </p><p>3.步长的向右和向下移动的幅度必须是一样的吗？</p><p>下面的想法，可以作为参考：</p><p>1.卷积核的尺寸不一定非得为正方形。长方形也可以，只不过通常情况下为正方形。如果要设置为长方形，那么首先得保证这层的输出形状是整数，不能是小数（一些框架会对小数进行四舍五入处理，一些会引起报错）。如果你的图像是边长为 28 的正方形。那么卷积层的输出就满足 [ (28 - kernel_size)/ stride ] + 1 ，这个数值得是整数才行，否则没有物理意义。池化层同理。FC 层的输出形状总是满足整数，其唯一的要求就是整个训练过程中 FC 层的输入得是定长的。如果你的图像不是正方形。那么在制作数据时，可以缩放到统一大小（非正方形），再使用非正方形的卷积核来使得卷积层的输出依然是整数。总之，撇开网络结果设定的好坏不谈，其本质上就是在做算术应用题：如何使得各层的输出是整数。 </p><p>2.由经验确定。通常情况下，靠近输入的卷积层，譬如第一层卷积层，会找出一些共性的特征，如手写数字识别中第一层我们设定卷积核个数为5个，一般是找出诸如”横线”、“竖线”、“斜线”等共性特征，我们称之为basic feature，经过池化后，在第二层卷积层，设定卷积核个数为20个，可以找出一些相对复杂的特征，如“横折”、“左半圆”、“右半圆”等特征，越往后，卷积核设定的数目越多，越能体现的特征就越细致，就越容易分类出来。比如你想分类出“0”的数字，你看到<img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.16.53.png" alt="截屏2020-04-1020.16.53"><br>这个特征，能推测是什么数字呢？只有越往后，检测识别的特征越多，试过才能慢慢能识别出</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.17.05.png" alt="截屏2020-04-1020.17.05"></p><p>这几个特征，那么我就能够确定这个数字是“0”。 </p><p>　　3.有stride_w和stride_h，表示左右步长和上下步长。如果用stride，则表示stride_h=stride_w=stride。</p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>神经网络的反向误差传播</title>
      <link href="/desirelife6.github.io/2019/08/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/"/>
      <url>/desirelife6.github.io/2019/08/30/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD/</url>
      
        <content type="html"><![CDATA[<h2 id="一、一般的全连接神经网络结构"><a href="#一、一般的全连接神经网络结构" class="headerlink" title="一、一般的全连接神经网络结构"></a>一、一般的全连接神经网络结构</h2><h3 id="1-1-“层”的概念"><a href="#1-1-“层”的概念" class="headerlink" title="1.1 “层”的概念"></a>1.1 “层”的概念</h3><p>每个“层”在神经网络中被实现为一个类，作为神经网络中的功能单位，类中定义了此层接受的输入，运算和输出。比如，负责激活函数的层就是Sigmoid层，ReLU层等等，负责矩阵相乘的就是上次提到的Affine层。<br>以Affine层和ReLU层为例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Affine</span><br><span class="line">X = np.random.rand(<span class="number">2</span>)  <span class="comment"># 输入</span></span><br><span class="line">W = np.random.rand(<span class="number">2</span>，<span class="number">3</span>)  <span class="comment"># 权重参数</span></span><br><span class="line">B = np.random.rand(<span class="number">3</span>)  <span class="comment"># 偏置</span></span><br><span class="line">Y = np.dot(X, W) + B    <span class="comment"># 得到相乘结果</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Relu</span>:</span>    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        self.mask = <span class="literal">None</span>        <span class="comment"># mask这个变量在反向传播时很重要，稍后会提到</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span>        <span class="comment"># 正向传播</span></span><br><span class="line">        self.mask = (x &lt;= <span class="number">0</span>)        </span><br><span class="line">        out = x.copy()        </span><br><span class="line">        out[self.mask] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(self, dout)</span>:</span>        <span class="comment"># 反向传播</span></span><br><span class="line">        dout[self.mask] = <span class="number">0</span>        </span><br><span class="line">        dx = dout</span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.34.07.png" alt="截屏2020-04-1020.34.07"></p><p>这里Affine中的 X、W、B 分别是形状为 (2,)、(2,3)、(3,) 的多维数组。这样一来，神经元的加权和可以用 Y = np.dot(X, W) + B 计算出来。然后，Y 经过激活函数转换后，传递给下一层。这就是神经网络正向传播的流程。调用激活层中的 forward 正向传播。</p><h2 id="二、正向传播时的梯度下降法"><a href="#二、正向传播时的梯度下降法" class="headerlink" title="二、正向传播时的梯度下降法"></a>二、正向传播时的梯度下降法</h2><p>在正向传播中，采用数值微分法求梯度<br>在每一层，采用数值微分法分别求损失函数对于该层的各个权重参数的偏导数，组合成梯度，然后令各参数向梯度下降的方向更新。代码其实很好懂，简直就像大白话，这里举一个简单的例子。<br> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求梯度</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numerical_gradient</span><span class="params">(f, x)</span>:</span>    <span class="comment"># x为传入的各参数的数组/多维数组</span></span><br><span class="line">    h = <span class="number">1e-4</span> <span class="comment"># 0.0001    </span></span><br><span class="line">    grad = np.zeros_like(x) <span class="comment"># 生成和x形状相同的数组</span></span><br><span class="line">    <span class="keyword">for</span> idx <span class="keyword">in</span> range(x.size):        </span><br><span class="line">        tmp_val = x[idx]    </span><br><span class="line">         <span class="comment"># f(x+h)的计算           </span></span><br><span class="line">        x[idx] = tmp_val + h        </span><br><span class="line">        fxh1 = f(x)</span><br><span class="line">        <span class="comment"># f(x-h)的计算        </span></span><br><span class="line">        x[idx] = tmp_val - h        </span><br><span class="line">        fxh2 = f(x)</span><br><span class="line">        <span class="comment"># 组合为梯度</span></span><br><span class="line">        grad[idx] = (fxh1 - fxh2) / (<span class="number">2</span>*h)        </span><br><span class="line">        x[idx] = tmp_val <span class="comment"># 还原值</span></span><br><span class="line">    <span class="keyword">return</span> grad</span><br><span class="line"></span><br><span class="line"><span class="comment"># 梯度下降法</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gradient_descent</span><span class="params">(f, init_x, lr=<span class="number">0.01</span>, step_num=<span class="number">100</span>)</span>:</span>  </span><br><span class="line">    x = init_x</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(step_num):       </span><br><span class="line">        grad = numerical_gradient(f, x)        </span><br><span class="line">        x -= lr * grad</span><br><span class="line">    <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure></p><p>梯度下降法的函数的参数中，f 为我们选用的损失函数，x为各层传入的参数数组，lr为学习率，也就是参数每次更新的程度，step_num为更新的轮数。</p><p><strong>这就是通过数值微分法计算损失函数关于权重参数的梯度。数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。<br>所以我们将学习一个能够高效计算权重参数的梯度的方法——误差反向传播法。</strong> </p><h2 id="三、误差反向传播法"><a href="#三、误差反向传播法" class="headerlink" title="三、误差反向传播法"></a>三、误差反向传播法</h2><h3 id="3-1-计算图"><a href="#3-1-计算图" class="headerlink" title="3.1 计算图"></a>3.1 计算图</h3><h4 id="3-1-1-利用计算图求解"><a href="#3-1-1-利用计算图求解" class="headerlink" title="3.1.1 利用计算图求解"></a>3.1.1 利用计算图求解</h4><p>计算图解题的情况下，需要按如下流程进行</p><ol><li>构建计算图。 </li><li>在计算图上，从左向右进行计算。（正向传播）</li></ol><p>现在我们尝试用计算图求解简单的问题<br>问题1： 太郎在超市买了2个100元一个的苹果，消费税是10%，请计算支付金额。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.34.22.png" alt="截屏2020-04-1020.34.22"></p><p>问题2：太郎在超市买了2个苹果、3个橘子。其中，苹果每个100元， 橘子每个150元。消费税是10%，请计算支付金额。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.34.31.png" alt="截屏2020-04-1020.34.31"></p><p>3.1.2 局部计算</p><p>计算图的特征是可以通过传递“局部计算”获得最终结果。“局部”这个 词的意思是“与自己相关的某个小范围”。局部计算是指，无论全局发生了什么， 都能只根据与自己相关的信息输出接下来的结果。<br>我们用一个具体的例子来说明局部计算。比如，在超市买了2个苹果和其他很多东西。此时，可以画出如图3-3所示的计算图。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.34.41.png" alt="截屏2020-04-1020.34.41"></p><p>如图3-3所示，假设（经过复杂的计算）购买的其他很多东西总共花费4000元。这里的重点是，各个节点处的计算都是局部计算。这意味着，例如苹果和其他很多东西的求和运算（4000 + 200 → 4200）并不关心4000这个数字是如何计算而来的，只要把两个数字相加就可以了。换言之，各个节点处只需进行与自己有关的计算（在这个例子中是对输入的两个数字进行加法运算），不用考虑全局。<br>综上，计算图可以集中精力于局部计算。无论全局的计算有多么复杂， 各个步骤所要做的就是对象节点的局部计算。虽然局部计算非常简单，但是通过传递它的计算结果，可以获得全局的复杂计算的结果。</p><h4 id="3-1-3-为何使用计算图"><a href="#3-1-3-为何使用计算图" class="headerlink" title="3.1.3 为何使用计算图"></a>3.1.3 为何使用计算图</h4><p>实际上，使用计算图最大的原因是，可以通过反向传播高效计算导数。 在介绍计算图的反向传播时，我们再来思考一下问题1。问题1中，假设我们想知道苹果价格的上涨会在多大程度上影响最终的支付金额，即求“支付金额关于苹果的价格的导数”。设苹果的价格为 x，支付金额为 L，则相当于求 $ \frac{dL}{dX} $。<br>先来看一下结果，如图3-4所示，可以通过计算图的反向传播求导数（关于如何进行反向传播，接下来马上会介绍）。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.34.52.png" alt="截屏2020-04-1020.34.52"></p><p>如图3-4所示，反向传播使用与正方向相反的箭头（粗线）表示。反向传播传递“局部导数”，将导数的值写在箭头的下方。在这个例子中，反向传播从右向左传递导数的值（1→1.1→2.2）。从这个结果中可知，“支付金额关于苹果的价格的导数”的值是2.2</p><p>“支付金额关于消费税的导数”“支付金额关于苹果的个数的导数”等也都可以用同样的方式算出来。并且, 计算中途求得的导数的结果（中间传递的导数）可以被共享，从而可以高效地计算多个导数。综上，计算图的优点是，可以通过正向传播和反向传 播高效地计算各个变量的导数值。</p><h3 id="3-2-链式法则"><a href="#3-2-链式法则" class="headerlink" title="3.2  链式法则"></a>3.2  链式法则</h3><h4 id="3-2-1-计算图的反向传播"><a href="#3-2-1-计算图的反向传播" class="headerlink" title="3.2.1 计算图的反向传播"></a>3.2.1 计算图的反向传播</h4><p>话不多说，让我们先来看一个使用计算图的反向传播的例子。假设存在 y = f(x)的计算，这个计算的反向传播如图3-4所示。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.01.png" alt="截屏2020-04-1020.35.01"></p><p>如图所示，反向传播的计算顺序是，将信号E乘以节点的局部导数 （ $\frac{dy}{dx}$），然后将结果传递给下一个节点。这里所说的局部导数是指正向传播中$y = f(x) $的导数，也就是y关于x的导数（ $\frac{dy}{dx}$）。把这个局部导数乘以上游传过来的值（本例中为E）， 然后传递给前面的节点。</p><h4 id="3-2-2-链式法则"><a href="#3-2-2-链式法则" class="headerlink" title="3.2.2 链式法则"></a>3.2.2 链式法则</h4><p>链式法则是关于复合函数的导数的性质，定义如下。</p><blockquote><p>如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。</p></blockquote><p>形如 $\frac{dZ}{dX}  =  \frac{dZ}{dt}  \frac{dt}{dZ} $， 即为求导的链式法则。高数内容，不再赘述。</p><h4 id="3-2-3-链式法则与计算图"><a href="#3-2-3-链式法则与计算图" class="headerlink" title="3.2.3 链式法则与计算图"></a>3.2.3 链式法则与计算图</h4><p>现在我们尝试将上式的链式法则的计算用计算图表示出来。如果用 “**2”节点表示平方运算的话，则计算图如图3-5所示。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.13.png" alt="截屏2020-04-1020.35.13"></p><p>因为$\frac{dz}{dt} = 2t $; $\frac{dt}{dx} = 1 $ ; 所以$\frac{dz}{dx}  = 2(x+y) $</p><h3 id="3-3-反向传播"><a href="#3-3-反向传播" class="headerlink" title="3.3 反向传播"></a>3.3 反向传播</h3><h4 id="3-3-1-加法的反向传播"><a href="#3-3-1-加法的反向传播" class="headerlink" title="3.3.1 加法的反向传播"></a>3.3.1 加法的反向传播</h4><p>加法反向传播将从上游传过来的导数（本例中是 ）乘以 1，然 后传向下游。也就是说，因为加法节点的反向传播只乘以1，所以输入的值 会原封不动地流向下一个节点。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.22.png" alt="截屏2020-04-1020.35.22"></p><h4 id="3-3-2-乘法的反向传播"><a href="#3-3-2-乘法的反向传播" class="headerlink" title="3.3.2 乘法的反向传播"></a>3.3.2 乘法的反向传播</h4><p>乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值” 后传递给下游。翻转值表示一种翻转关系，如图5-12所示，正向传播时信号 是x的话，反向传播时则是y；正向传播时信号是y的话，反向传播时则是x。 </p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.31.png" alt="截屏2020-04-1020.35.31"></p><h4 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h4><p>结合加法和乘法，以苹果为例，尝试填入这些空格</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.41.png" alt="截屏2020-04-1020.35.41"></p><h3 id="3-4-激活函数层的反向传播实现"><a href="#3-4-激活函数层的反向传播实现" class="headerlink" title="3.4 激活函数层的反向传播实现"></a>3.4 激活函数层的反向传播实现</h3><h4 id="3-4-1-ReLU-层"><a href="#3-4-1-ReLU-层" class="headerlink" title="3.4.1 ReLU 层"></a>3.4.1 ReLU 层</h4><p>激活函数ReLU的导数为<img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.35.50.png" alt="截屏2020-04-1020.35.50"><br>如果正向传播时的输入x大于0，则反向传播会将上游的 值原封不动地传给下游。反过来，如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处<br>所以在开始时提到的ReLU层的mask变量，是用来存储正向传播输入是否为0的变量，它是由True/False构成的NumPy数组，它会把正向传播时的输入x的元素中小于等于0的地方保存为True，其他地方（大于0的元素）保存为False。在反向传播中尤其重要。<br>计算图表示即为</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.36.00.png" alt="截屏2020-04-1020.36.00"></p><h4 id="3-4-2-Sigmoid层"><a href="#3-4-2-Sigmoid层" class="headerlink" title="3.4.2 Sigmoid层"></a>3.4.2 Sigmoid层</h4><p>步骤1<br>“/”节点表示 ，它的导数可以解析性地表示为下式。<br>$ \frac{dy}{dx} = - \frac{1}{x^2} = - y^2 $<br>反向传播时，会将上游的值乘以$−y^2$（正向传播的输出的平方乘以−1后的值）后，再传给下游。</p><p>步骤2<br> “+”节点将上游的值原封不动地传给下游。</p><p>步骤3<br>“exp”节点表示y = exp(x)，它的导数由下式表示。<br>$ \frac{dy}{dx} = exp(x) $<br>计算图中，上游的值乘以正向传播时的输出（这个例子中是exp(−x)）后， 再传给下游。</p><p>步骤4<br>“×”节点将正向传播时的值翻转后做乘法运算。因此，这里要乘以−1。</p><p>最终结果为</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.36.11.png" alt="截屏2020-04-1020.36.11"></p><p>这里要注意， 这个值只根据正向传播时的输入x和输出y就可以算出来,所以sigmoid的计算图可以简化为sigmoid节点，简洁版的计算图可以省略反向传播中的计算过程，因此计算效率更高。此外， 通过对节点进行集约化，可以不用在意Sigmoid层中琐碎的细节，而只需要专注它的输入和输出，这一点也很重要。 </p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.43.46.png" alt="截屏2020-04-1020.43.46"></p><h3 id="3-5-Affine-Softmax层的实现"><a href="#3-5-Affine-Softmax层的实现" class="headerlink" title="3.5 Affine/Softmax层的实现"></a>3.5 Affine/Softmax层的实现</h3><h4 id="3-5-1-Affine层"><a href="#3-5-1-Affine层" class="headerlink" title="3.5.1 Affine层"></a>3.5.1 Affine层</h4><p>神经网络的正向传播中，为了计算加权信号的总和，使用了矩阵的乘积运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Affine</span><br><span class="line">X = np.random.rand(<span class="number">2</span>)  <span class="comment"># 输入</span></span><br><span class="line">W = np.random.rand(<span class="number">2</span>，<span class="number">3</span>)  <span class="comment"># 权重参数</span></span><br><span class="line">B = np.random.rand(<span class="number">3</span>)  <span class="comment"># 偏置</span></span><br><span class="line">Y = np.dot(X, W) + B    <span class="comment"># 得到相乘结果</span></span><br></pre></td></tr></table></figure><blockquote><p>神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿 射变换” A。因此，这里将进行仿射变换的处理实现为“Affine层”。</p></blockquote><p>现在将它用计算图表示出来，要注意X、W、B是矩阵（多维数组）。 之前我们见到的计算图中各个节点间流动的是标量，而这个例子中各个节点间传播的是矩阵。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.36.33.png" alt="截屏2020-04-1020.36.33"></p><p>现在我们来考虑图 3-14 的计算图的反向传播。以矩阵为对象的反向传播，通过数学推导可得到下式<br>$$ \frac{dL}{dX} = \frac{dL}{dY} * W^T $$<br>$$ \frac{dL}{dW} = X^T * \frac{dL}{dY} $$<br>表示为计算图即为：</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.36.45.png" alt="截屏2020-04-1020.36.45"></p><p>其中值得注意的是,X与$\frac{dL}{dX}$形状相同，W与$\frac{dL}{dW}$形状相同,从下式也容易看出</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.36.56.png" alt="截屏2020-04-1020.36.56"></p><h4 id="3-5-2-批版本的Affine层"><a href="#3-5-2-批版本的Affine层" class="headerlink" title="3.5.2 批版本的Affine层"></a>3.5.2 批版本的Affine层</h4><p>前面介绍的Affi  ne层的输入X是以单个数据为对象的。现在我们考虑N 个数据一起进行正向传播的情况，也就是批版本的Affine层。<br>先来看计算图</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.37.09.png" alt="截屏2020-04-1020.37.09"></p><p>与刚刚不同的是，现在输入X的形状是(N,2)。之后就和前面一样，在计算图上进行单纯的矩阵计算。<br><strong>加上偏置时，需要特别注意。正向传播时，偏置被加到X·W的各个数据上。比如，N = 2（数据为2个）时，偏置会被分别加到这2个数据（各自 的计算结果）上。因此， 反向传播时，各个数据的反向传播的值需要汇总为偏置的元素。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>dY = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>,], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dY </span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],       </span><br><span class="line">       [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]]) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dB = np.sum(dY, axis=<span class="number">0</span>) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dB </span><br><span class="line">array([<span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>])</span><br></pre></td></tr></table></figure><p>这个例子中，假定数据有2个（N = 2）。偏置的反向传播会对这2个数据的导数按元素进行求和。因此，这里使用了np.sum()对第0轴（以数据为单位的轴，axis=0）方向上的元素进行求和。 </p><h4 id="3-5-3-Softmax-with-Loss-层"><a href="#3-5-3-Softmax-with-Loss-层" class="headerlink" title="3.5.3 Softmax-with-Loss 层"></a>3.5.3 Softmax-with-Loss 层</h4><p>上次我们提到过，softmax函数会将输入值正规化之后再输出。比如手写数字识别时，Softmax层的输出如下所示。</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.37.18.png" alt="截屏2020-04-1020.37.18"></p><blockquote><p>神经网络中进行的处理有推理（inference）和学习两个阶段。神经网络的推理通常不使用Softmax层。比如，用上图的网络进行推理时， 会将最后一个Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（Softmax层前面的Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要Softmax层。 不过，神经网络的学习阶段则需要Softmax层。</p></blockquote><p>来看softmax的计算图，导出过程比较复杂，这里只给出最终结果</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.37.25.png" alt="截屏2020-04-1020.37.25"></p><p>不感兴趣的话可以看简化版本</p><p><img src="/desirelife6.github.io/.com//%E6%88%AA%E5%B1%8F2020-04-1020.37.34.png" alt="截屏2020-04-1020.37.34"></p><p>Softmax层的反向传播得到了 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。由于$（y_1,y_2,y_3）$是 Softmax层的输出，$（ t_1,t_2,t_3）$是监督数据，所以$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$是 Softmax层的输出和教师标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层，这是神经网络学习中的重要性质。<br>神经网络学习的目的就是通过调整权重参数，使神经网络的输出（Softmax 的输出）接近教师标签。因此，必须将神经网络的输出与教师标签的误差高效地传递给前面的层。刚刚的$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$正是 Softmax层的输出与教师标签的差，直截了当地表示了当前神经网络的输出与教师标签的误差。 </p><blockquote><p>使用交叉熵误差作为softmax函数的损失函数后，反向传播得到 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样 “漂亮”的结果。实际上，这样“漂亮” 的结果并不是偶然的，而是为了得到这样的结果，特意设计了交叉熵误差函数。回归问题中输出层使用“恒等函数”，损失函数使用 “平方和误差”，也是出于同样的理由。也就是说，使用“平 方和误差”作为“恒等函数”的损失函数，反向传播才能得到$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。</p></blockquote><h2 id="四、神经网络学习全貌"><a href="#四、神经网络学习全貌" class="headerlink" title="四、神经网络学习全貌"></a>四、神经网络学习全貌</h2><p>前提<br>神经网络中有合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为学习<br>神经网络的学习分为下面4个步骤。<br>步骤1（mini-batch）<br>从训练数据中随机选择一部分数据。<br>步骤2（计算梯度）<br>计算损失函数关于各个权重参数的梯度。<br>步骤3（更新参数）<br>将权重参数沿梯度方向进行微小的更新。<br>步骤4（重复）<br>重复步骤1、步骤2、步骤3。<br>这次介绍的误差反向传播法会在步骤2中出现。上一次中，我们利用数值微分求得了这个梯度。数值微分虽然实现简单，但是计算要耗费较多的时间，而误差反向传播法可以快速高效地计算梯度。</p><p><strong>还有一篇CNN噢，欢迎持续关注 :-D</strong></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 神经网络 </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/desirelife6.github.io/2019/08/30/hello-world/"/>
      <url>/desirelife6.github.io/2019/08/30/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>关于作者</title>
      <link href="/desirelife6.github.io/about/index.html"/>
      <url>/desirelife6.github.io/about/index.html</url>
      
        <content type="html"><![CDATA[<h2 id="我是谁"><a href="#我是谁" class="headerlink" title="我是谁"></a>我是谁</h2><h3 id="我是一枚爱吃饭爱睡觉的可爱程序猿"><a href="#我是一枚爱吃饭爱睡觉的可爱程序猿" class="headerlink" title="我是一枚爱吃饭爱睡觉的可爱程序猿"></a>我是一枚爱吃饭爱睡觉的可爱程序猿</h3><h2 id="博客干嘛用"><a href="#博客干嘛用" class="headerlink" title="博客干嘛用"></a>博客干嘛用</h2><h3 id="我想干嘛干嘛鸭嘻嘻嘻"><a href="#我想干嘛干嘛鸭嘻嘻嘻" class="headerlink" title="我想干嘛干嘛鸭嘻嘻嘻"></a>我想干嘛干嘛鸭嘻嘻嘻</h3><p>其实可以来github给我star ： <a href="https://github.com/Desirelife6">https://github.com/Desirelife6</a></p>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>categories</title>
      <link href="/desirelife6.github.io/categories/index.html"/>
      <url>/desirelife6.github.io/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>tags</title>
      <link href="/desirelife6.github.io/tags/index.html"/>
      <url>/desirelife6.github.io/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
