<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CentOS搭建Apache服务器和ftp服务器]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F13%2F%E5%9C%A8CentOS%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAApache%E6%9C%8D%E5%8A%A1%E5%99%A8%E2%80%94%E2%80%94%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A%2F</url>
    <content type="text"><![CDATA[CentOS搭建Apache服务器和ftp服务器[TOC] 1. Apache安装使用su root得到权限后使用yum install httpd安装Apache服务器 使用rpm -qa | grep httpd进行验证，可见已经安装完成 2. 检验网络的连通性由下图可知网络连通性良好 3. 启动apache服务器，然后用客户机端访问默认界面和个人界面3.1 启动apache服务，访问默认界面使用systemctl start httpd启动apache服务并使用systemctl stop firewalld关闭防火墙 使用浏览器访问，访问正常 进入var/www/html文件夹下新建index.html，修改默认主页后再次访问 3.2 创建用户个人界面在用户desirelife目录下新建public_html目录，并修改其权限 写入个人主页的index.html，内容为一行字： “This is Desirelife’s web” 得到root权限并修改/etc/httpd/conf.d/userdir文件，允许用户架设个人web站点。 SELLinux模式有时会阻碍客户机的访问，因此我们使用setenforce命令把SELLinux设置为允许模式，getenforce命令查看设置后的SELLinux模式。 然后重启服务，在客户机端进行访问。 4. 配置虚拟主机 分别给网卡配置两个ip地址23.17.235和172.23.17.233（这里的IP地址需要和虚拟机上的IP地址网段保持一致） 虚拟机上的ip地址如图1所示，为192.168.159.128 分别创建“/var/www/ip4”和“/var/www/ip5”两个主目录和默认首页文件。 在/etc/httpd/conf/httpd.conf文件中，设置基于IP地址的虚拟主机，配置内容如下 重启服务后再在客户端访问，可在客户端输入http://IP形式的URL地址访问虚拟主机，则可以访问对应的虚拟主机。 5. vsftpd的安装和配置5.1 安装ftp服务使用yum软件管理包安装ftp服务 查询已安装的软件过滤出vsftpd，可知安装成功 5.2 启动ftp服务启动以后直接用localhost登录，发现与服务器的连接断开，如图所示 这是因为VSFTPD是一个FTP服务器程序，SELinux是CentOS的防火墙组件， vsftpd 默认被 SELinux 拦截。可以通过在linux中设置ftp允许访问解决这个问题。如图所示，将ftpd_full_access设置为on 配置文件允许匿名访问等 启动服务，此时可以通过ip地址访问服务器，查询ftp服务的状态，可见已经处于active状态 查询21端口 在本地使用anonymous匿名登陆进行验证，保证返回220表示服务正常，230表示登陆成功 使用客户机，用ip进行访问，可以看到系统预设的pub文件夹，表示访问正常 5.3 创建ftp用户 在centos添加用户ftpuser，并设置密码（这里由于密码设置过于简单被迫设置了好几次XD），限制该用户的登陆 创建用户目录并指定特定用户的登陆目录]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>-Computer Networking</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java——注解]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F2019-11-03-Java%E2%80%94%E2%80%94%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Java——注解一、什么是注解​ 注解也叫元数据，例如我们常见的@Override和@Deprecated，注解是JDK1.5版本开始引入的一个特性，用于对代码进行说明，可以对包、类、接口、字段、方法参数、局部变量等进行注解 一般常用的注解可以分为三类： 一类是Java自带的标准注解，包括@Override（标明重写某个方法）、@Deprecated（标明某个类或方法过时）和@SuppressWarnings（标明要忽略的警告），使用这些注解后编译器就会进行检查 一类为元注解，元注解是用于定义注解的注解，包括@Retention（标明注解被保留的阶段）、@Target（标明注解使用的范围）、@Inherited（标明注解可继承）、@Documented（标明是否生成javadoc文档） 一类为自定义注解，可以根据自己的需求定义注解 二、注解的用途 生成文档，通过代码里标识的元数据生成javadoc文档。 编译检查，通过代码里标识的元数据让编译器在编译期间进行检查验证。 编译时动态处理，编译时通过代码里标识的元数据动态处理，例如动态生成代码。 运行时动态处理，运行时通过代码里标识的元数据动态处理，例如使用反射注入实例 三、注解的使用1、Java自带的标准注解常见标准的Annotation： 1.）Override java.lang.Override是一个标记类型注解，它被用作标注方法。它说明了被标注的方法重载了父类的方法，起到了断言的作用。如果我们使用了这种注解在一个没有覆盖父类方法的方法时，java编译器将以一个编译错误来警示。 2.）Deprecated Deprecated也是一种标记类型注解。当一个类型或者类型成员使用@Deprecated修饰的话，编译器将不鼓励使用这个被标注的程序元素。所以使用这种修饰具有一定的“延续性”：如果我们在代码中通过继承或者覆盖的方式使用了这个过时的类型或者成员，虽然继承或者覆盖后的类型或者成员并不是被声明为@Deprecated，但编译器仍然要报警。 3.）SuppressWarnings SuppressWarning不是一个标记类型注解。它有一个类型为String[]的成员，这个成员的值为被禁止的警告名。对于javac编译器来讲，被-Xlint选项有效的警告名也同样对@SuppressWarings有效，同时编译器忽略掉无法识别的警告名。 @SuppressWarnings(“unchecked”) 这种注解的使用非常简单，只需在需要注解的地方标明某个注解即可，例如在方法上注解： 123456public class Test &#123; @Override public String tostring() &#123; return "override it"; &#125;&#125; 例如在类上注解： 1234@Deprecatedpublic class Test &#123;&#125; 2、元注解java.lang.annotation提供了四种元注解，专门注解其他的注解（在自定义注解的时候，需要使用到元注解）： @Documented @Retention @Target @Inherited 注解 作用 @Target 表示该注解用于什么地方。如果不明确指出，该注解可以放在任何地方 ElementType.TYPE : 用于描述类、接口或enum声明 ElementType.FIELD : 成员变量、对象、属性（包括enum实例） ElementType.METHOD : 用于描述方法 Element.PARAMETER : 用于描述参数 Element.CONSTRUCTOR : 用于描述构造器 Element.LOCAL_VARIABLE : 用于描述局部变量 ElementType.ANNOTATION_TYPE : 用于描述类、接口(包括注解类型) 或enum声明 ElementType.PACKAGE : 用于描述包 @Retention 定义该注解的生命周期 RetentionPolicy.SOURCE : 在编译阶段丢弃。这些注解在编译结束之后就不再有任何意义，所以它们不会写入字节码(@Override, @SuppressWarnings都属于这类注解) RetentionPolicy.CLASS : 在类加载的时候丢弃。在字节码文件的处理中有用。注解默认使用这种方式 RetentionPolicy.RUNTIME : 始终不会丢弃，运行期也保留该注解，因此可以使用反射机制读取该注解的信息。我们自定义的注解通常使用这种方式 @Document 表示是否将注解信息添加在java文档中 @Inherited 定义该注释和子类的关系 注：如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation 3、自定义注解自定义注解类编写的一些规则: Annotation型定义为@interface, 所有的Annotation会自动继承java.lang.Annotation这一接口,并且不能再去继承别的类或是接口. 参数成员只能用public或默认(default)这两个访问权修饰 参数成员只能用基本类型byte,short,char,int,long,float,double,boolean八种基本数据类型和String、Enum、Class、annotations等数据类型,以及这一些类型的数组. 要获取类方法和字段的注解信息，必须通过Java的反射技术来获取 Annotation对象,因为你除此之外没有别的获取注解对象的方法 注解也可以没有定义成员, 不过这样注解就没啥用了PS:自定义注解需要使用到元注解 12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface Test &#123; &#125; ​ 在注解中一般会有一些元素以表示某些值。注解的元素看起来就像接口的方法，唯一的区别在于可以为其制定默认值。没有元素的注解称为标记注解，上面的@Test就是一个标记注解。​ 注解的可用的类型包括以下几种：所有基本类型、String、Class、enum、Annotation、以上类型的数组形式。元素不能有不确定的值，即要么有默认值，要么在使用注解的时候提供元素的值。而且元素不能使用null作为默认值。注解在只有一个元素且该元素的名称是value的情况下，在使用注解的时候可以省略“value=”，直接写需要的值即可。 四、反射机制与注解机制AnnotatedElement 接口是所有程序元素（Class、Method和Constructor）的父接口，所以程序通过反射获取了某个类的AnnotatedElement对象之后，程序就可以调用该对象的如下四个个方法来访问Annotation信息： 方法 含义 T getAnnotation(Class annotationClass) 返回改程序元素上存在的、指定类型的注解，如果该类型注解不存在，则返回null Annotation[] getAnnotations() 返回该程序元素上存在的所有注解。 boolean is AnnotationPresent(Class&lt;?extends Annotation&gt; annotationClass) 判断该程序元素上是否包含指定类型的注解，存在则返回true，否则返回false Annotation[] getDeclaredAnnotations() 返回直接存在于此元素上的所有注解。与此接口中的其他方法不同，该方法将忽略继承的注解。（如果没有注释直接存在于此元素上，则返回长度为零的一个数组。）该方法的调用者可以随意修改返回的数组；这不会对其他调用者返回的数组产生任何影响。 default T[] getAnnotationsByType(Class annotationClass) 返回该元素制定类型的注解 default T getDeclaredAnnotation( Class annotationClass) 返回直接存在与该元素上的所有注解 default T[] getDeclaredAnntationsByType(Class annotationClass) 返回直接存在该元素上某类型的注解 接下来让我们在代码中看看二者的结合 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788//定义一个可以注解在Class,interface,enum上的注解@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnTargetType &#123; /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default "MyAnTargetType我是定义在类接口枚举类上的注解元素value的默认值";&#125;//定义一个可以注解在PARAMETER上的注解@Target(&#123;ElementType.PARAMETER&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnTargetParameter &#123; /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default "MyAnTargetParameter我是定义在参数上的注解元素value的默认值";&#125;// 定义一个可以注解在METHOD上的注解@Target(&#123;ElementType.METHOD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnTargetMethod &#123; /** * 定义注解的一个元素 并给定默认值 * * @return */ String value() default "MyAnTargetMethod我是定义在方法上的注解元素value的默认值";&#125;// 定义一个可以注解在FIELD上的注解@Target(&#123;ElementType.FIELD&#125;)@Retention(RetentionPolicy.RUNTIME)public @interface MyAnTargetField &#123; /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default "MyAnTargetField我是定义在字段上的注解元素value的默认值";&#125;//创建一个使用了以上四种注解的类@MyAnTargetTypepublic class AnnotationTest &#123; @MyAnTargetField private String field = "我是字段"; @MyAnTargetMethod("测试方法") public void test(@MyAnTargetParameter String args) &#123; System.out.println("参数值 === " + args); &#125;&#125;public class Main&#123; public static void main(String[] args) &#123; // 获取类上的注解MyAnTargetType MyAnTargetType t = AnnotationTest.class.getAnnotation(MyAnTargetType.class); System.out.println("类上的注解值 === " + t.value()); MyAnTargetMethod tm = null; try &#123; // 根据反射获取AnnotationTest类上的test方法 Method method = AnnotationTest.class.getDeclaredMethod("test", String.class); // 获取方法上的注解MyAnTargetMethod tm = method.getAnnotation(MyAnTargetMethod.class); System.out.println("方法上的注解值 === " + tm.value()); // 获取方法上的所有参数注解 循环所有注解找到MyAnTargetParameter注解 Annotation[][] annotations = method.getParameterAnnotations(); for (Annotation[] tt : annotations) &#123; for (Annotation t1 : tt) &#123; if (t1 instanceof MyAnTargetParameter) &#123; System.out.println("参数上的注解值 === " + ((MyAnTargetParameter) t1).value()); &#125; &#125; &#125; method.invoke(new AnnotationTest(), "改变默认参数"); // 获取AnnotationTest类上字段field的注解MyAnTargetField MyAnTargetField fieldAn = AnnotationTest.class.getDeclaredField("field").getAnnotation(MyAnTargetField.class); System.out.println("字段上的注解值 === " + fieldAn.value()); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; 运行结果如下： 12345类上的注解值 === MyAnTargetType我是定义在类接口枚举类上的注解元素value的默认值方法上的注解值 === 测试方法参数上的注解值 === MyAnTargetParameter我是定义在参数上的注解元素value的默认值参数值 === 改变默认参数字段上的注解值 === MyAnTargetField我是定义在字段上的注解元素value的默认值 最后再写一个关于@Inherited例子： 1234567891011121314151617@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inheritedpublic @interface MyAnTargetType &#123; /** * 定义注解的一个元素 并给定默认值 * @return */ String value() default "MyAnTargetType我是定义在类接口枚举类上的注解元素value的默认值";&#125;public class Main extends AnnotationTest&#123; public static void main(String[] args) &#123; MyAnTargetType t2 = Main.class.getAnnotation(MyAnTargetType.class); System.out.println("类上的注解值 === "+t2.value()); &#125;&#125; 运行如下: 1类上的注解值 === 我是定义在类接口枚举类上的注解元素value的默认值 说明已经获取到了父类AnnotationTest的注解了如果MyAnTargetType去掉@Inherited注解运行则报错如下： 12Exception in thread "main" java.lang.NullPointerException at com.company.Main.main(Main.java:41) 最后借用下别人的Java注解的基础知识点导图 5713484-e2afe3f5096f32e9.png]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java——内存泄漏]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F2019-11-03-Java%E2%80%94%E2%80%94%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%2F</url>
    <content type="text"><![CDATA[Java——内存泄漏本文将会介绍： C++中的内存泄露 Java内存管理与垃圾回收 Java中的内存泄漏 一、C++中的内存泄露在大一上C++面向对象课的时候老师告诉我们，new 和 delete 一定要配对使用！不然就会造成内存泄漏。在当时听的迷迷糊糊的，只是记住了。但到底什么是内存泄漏？为什么 new 出来的内存不 delete 就会造成内存泄漏呢？这就要从C++的运行时内存区域划分来讲起了 C++运行时内存区域划分咱们先来看这样一段代码—— 1234567891011121314151617181920#include &lt;iostream&gt; using namespace std;int var1 = 1;int* arr = new int[2];void memLeak();int main()&#123; while(1) memLeak(); return 0;&#125;void memLeak()&#123; int a = 0; int* b = new int[2]; // do something with b&#125; 我们声明的这些变量分别存放在不同的内存区域，如下图—— 注：stack和静态/全局区的格子中展示的是存放的值，而Heap中展示的是地址 我们先看看这几个分区的介绍： 栈区(stack)：存放局部变量和参数，申请和释放都由编译器自动完成堆区(heap)：动态内存分配，申请和释放都是由程序员控制。静态区/全局区(static)：存放全局变量和静态变量。 再结合我们的代码来看，我们在memLeak函数中声明的局部变量 a 和 c 都存放在栈区，而全局变量var1则存放在静态全局区。存放在栈中的变量我们无需进行管理，随着函数的返回，分配的内存自动进行了回收；而存放在静态/全局区中的变量的生命周期是跟随整个程序的，我们也无需在代码中进行内存的管理。 那new出来的内存呢？从图中我们可以看出，我们在函数中执行 int* b = new int[2]; 并非是在栈中开辟了两个int大小的空间，而是在堆中分配了空间，并将这片空间的头地址赋值给b，与此同时，插一面小旗子，占山为王，说这一块地已经是我的了，只有我能在上面撒欢，别人不许过来！但是在函数结束之后，这一块内存并不会自动释放（拔掉小旗子，这一块地方可以被别人使用）， 如果不手动调用 delete 去释放内存，其生命周期与会与程序一样长。 就我个人总结来说的话，内存泄漏就是在堆上已经无用的内存并未被回收而无法挪作他用的情况。 C++中的内存泄漏 之前的代码就是一个内存泄漏的例子，在memLeak函数外，我们没有再用到 b 申请的内存，在memLeak函数中，我们并没有释放动态申请的内存。我们在外面死循环调用函数，会导致在堆中越来越多的人“占地为王”，最终导致堆被占满，其他地方无法再正常的申请到堆中内存。 123456789101112#include &lt;iostream&gt;using namespace std;int main()&#123; int b = new int[1024]; // #1 this memory was not recycled，4 KB memory was wasted //.. b = new int[10000]; //do some things delete b; //do other things return 0;&#125; 同时还在上述情况，一开始b 指向了一片分配的内存(注释1)，而 b 又指向了其他内存，此时再也没有办法可以访问到注释1处分配的内存，导致内存泄漏。 二、Java内存管理和垃圾回收 JVM 运行时内存模型 Java 虚拟机栈 Java 堆 方法区 相信大家此时对栈和堆已经有了一定的认识，其实方法区也和 C++ 中的静态/全局区有一些类似，是用于存储虚拟机加载的类信息、常量、静态变量、及时编译后的代码等数据的地方。 同 C++ 一样，Java 中 new 关键字也是在堆上分配内存，将首地址赋给（*句柄，句柄的地址再赋给）局部变量。而与 C++ 不同的是，JVM 提供了 GC(Garbage Collection) 机制来管理 Java 堆中的内存。 （* 句柄…）： 分别对应句柄使用访问和使用直接指针访问的两种对象访问模式，在 Sun 公司 HotSpot 虚拟机中是采用直接指针的访问模式（即直接定位对象）。 GC 在讨论 GC 之前，我们先来想一个问题，为什么堆区需要专门的垃圾回收机制？ 一个接口中的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间才内知道创建那些对象，这部分的内存分配是动态的。——《深入理解Java虚拟机》 我个人理解，首先这一片内存是动态分配的，我们无法从编译期得知需要分配多少内存，其次因为程序不知道这一块内存什么时候会没用，所以需要一个算法，来告诉虚拟机，这一片内存已经不会再被使用了，即对象已死亡。 可达性分析算法 在Java GC的主流实现中，都是通过可达性分析 (Reachability analysis) 来实现判定对象是否存活的。这个算法的基本思想就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，所走过的路径称为引用链 (Reference Chain)，当一个对象到 GC Roots 没有任何引用链的时，则证明此对象是不可用的。在Java语言中，可作为 GC Roots 的对象包括以下几种》 虚拟机栈中引用的对象》 方法区中类静态属性引用的对象》 方法区中常量引用的对象》 本地方法栈中 JNI 引用的对象——《深入理解Java虚拟机》 周志明 举个例子~ 123456789101112131415161718192021class Test&#123; int id; Test(int id)&#123; this.id = id; &#125; public static void main(String []args)&#123; Test test = new Test(0); System.gc(); System.out.println("--------------"); test = null; System.gc(); &#125; @Override public void finalize()&#123; System.out.println("Test" + id); &#125;&#125; 运行结果： 12--------------Test0 一开始，在栈中存在一个GC Root test, 它指向了在堆中的Test对象，这个对象在存在一条到GC Roots的引用链，此时调用 System.gc() 不会回收该对象，而后我们执行了 test = null，断开了对象与 GC Root 的引用链，表明此对象已经死亡，再次调用 System.gc() 对象被回收（执行了finalize方法）： 三、Java中的内存泄露在第二部分我们介绍了Java的 GC 机制，由虚拟机通过一定的算法在帮我们在 gc 的时候去释放一些堆中无用的内存。但这并不能完全避免 Java 的内存泄漏，当引用链的生命周期长于对象的生命周期时，还是会出现内存泄漏的情况。在网上搜集了一些内存泄漏的例子—— 静态集合类引起内存泄漏 123456789static Vector v = new Vector(10);void fun()&#123; for (int i = 1; i&lt;100; i++) &#123; Object o = new Object(); v.add(o); o = null; &#125;&#125; 在这个例子中，循环申请Object 对象，并将所申请的对象放入一个Vector 中，如果仅仅释放引用本身（o=null），那么Vector 仍然引用该对象，所以这个对象对GC 来说是不可回收的。因此，如果对象加入到Vector 后，还必须从Vector 中删除，最简单的方法就是将Vector对象设置为null。 当集合里面的对象属性被修改后，再调用remove()方法时不起作用 123456789101112131415161718192021public static void main(String[] args)&#123; Set&lt;Person&gt; set = new HashSet&lt;Person&gt;(); Person p1 = new Person("唐僧","pwd1",25); Person p2 = new Person("孙悟空","pwd2",26); Person p3 = new Person("猪八戒","pwd3",27); set.add(p1); set.add(p2); set.add(p3); System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:3 个元素! p3.setAge(2); //修改p3的年龄,此时p3元素对应的hashcode值发生改变 set.remove(p3); //此时remove不掉，造成内存泄漏 set.add(p3); //重新添加，居然添加成功 System.out.println("总共有:"+set.size()+" 个元素!"); //结果：总共有:4 个元素! for (Person person : set) &#123; System.out.println(person); &#125;&#125; 单例模式 12345678910111213141516171819class A&#123; public A()&#123; B.getInstance().setA(this); &#125;//...&#125;//B类采用单例模式class B&#123; private A a; private static B instance=new B(); public B()&#123;&#125; public static B getInstance()&#123; return instance; &#125; public void setA(A a)&#123; this.a=a; &#125; //getter... &#125; 显然B采用singleton模式，它持有一个A对象的引用，而这个A类的对象将不能被回收。想象下如果A是个比较复杂的对象或者集合类型会发生什么情况 非静态内部类 123456789101112131415public class MainActivity extends Activity &#123; ... Handler handler = new MyHandler(); Runnable ref1 = new MyRunable(); Runnable ref2 = new Runnable() &#123; @Override public void run() &#123; // &#125; &#125;; ... public void dosomething()&#123; handler.post(ref1); &#125;&#125; ref1和ref2的区别是，ref2使用了匿名内部类。我们来看看运行时这两个引用的内存： image 可以看到ref2这个匿名类的实现对象里面多了一个引用：this$0这个引用指向MainActivity.this，也就是说当前的MainActivity实例会被ref2持有，如果将这个引用再传入一个异步线程，此线程和此Acitivity生命周期不一致的时候，就造成了Activity的泄露。同理，Handler也是这样。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java——多线程]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F2019-11-03-Java%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Java——多线程 线程的五个状态新建，就绪，执行，等待，销毁 新建线程需要调用start()方法才会进入就绪状态 处于就绪状态的线程并不一定立即被执行，而是听从CPU调度，即将被执行，所以被称为就绪 处于等待状态的线程不会被CPU调度 如何创建新的线程 方法一 123456789101112131415public class TestThread extends Thread &#123; //默认构造方法 public TestThread()&#123;&#125; //传入的String参数为线程名称 public TestThread(String name) &#123; super(name); &#125; //该方法在线程由就绪转为执行时被调用 @Override public void run() &#123; super.run(); System.out.println(this.getName()); &#125;&#125; 这样我们已经声明了自己的线程类，对于不同的线程，他们的区别主要在于他们的run()方法内的业务逻辑不同，同时我们需要注意的是，我们还没有实例化对象，也就是说现在新的线程还没有被创建. 1234public static void main(String[] args) &#123; TestThread thread1 = new TestThread("新线程"); thread1.start();&#125; 只有当线程对象的start()方法被调用时，该线程才真正进入就绪状态，等待CPU调度，进入执行状态. 方法二 12345//实例化runnable对象TestRunnable runnable = new TestRunnable();//实例化Thread对象，将runnable对象作为参数Thread thread2 = new Thread(runnable);thread2.start(); 当我们去自定义自己的Thread时候，我们只是希望重写它的run()方法内的业务逻辑，所以我们可以实例化 Runnable 对象，作为 Thread 的构造参数. 使用Runnable 我们可以避免单继承的问题这实际上是一种静态代理的设计模式 状态切换及相关方法 join:类方法，使调用该方法的线程进入就绪状态，阻塞其它线程，直到该线程执行完毕yield:Thread 静态方法, 在哪个线程中调用，就使那个线程进入就绪状态，等待 cpu 调度sleep:Thread 静态方法，与 yield 相比可以指定时间不会让出锁，多用于倒计时或模拟网络延时currentThread:Thread 静态方法，在哪个线程中调用就返回哪个线程的引用setPriority: MAX_PRIORITY -&gt; 10, MIN_PRIORITY -&gt; 1, NORM_PRRIORITY -&gt; 0 优先级高的线程不能保证一定先执行，只是抢占资源时几率大一些，是否执行要服从 cpu 的调度 123456789101112131415161718192021222324252627public static void main(String[] args) throws InterruptedException &#123;/** * 控制台会交替输出 1 和 2 * 实际上多线程在很多情况下不是真正的并行 * 而是 cpu 在极短的时间内不断切换线程来达到异步的效果 */ Thread t1 = new Thread() &#123; @Override public void run() &#123; super.run(); int i = 1010; while (i-- &gt; 0) System.out.println("1"); &#125; &#125;; Thread t2 = new Thread() &#123; @Override public void run() &#123; super.run(); int i = 1010; while (i-- &gt; 0) System.out.println("2"); &#125; &#125;; t1.start(); t2.start();&#125; 当我们运行如下代码，就会发现所有的 2 会在 1 输出之后 123t1.start();t1.join();t2.start(); 下面的代码输出会出现同样的结果，因为我们在线程2中调用了静态方法 sleep，并且 1000ms 是一个足够让 t1 完成输出的时间 1234567891011121314Thread t2 = new Thread() &#123; @Override public void run() &#123; super.run(); int i = 1010; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; while (i-- &gt; 0) System.out.println("2"); &#125;&#125;; 锁 进程：资源分配的单位，进程间切换会有较大的开销线程：调度和执行的单位，线程间切换开销较小，但是线程仍然具有独立的运行栈和计数器（PC）多线程会涉及到并发问题，因为线程之间共享数据内存单元，内存地址，可以访问相同的变量和对象。而且该问题在无论是否是真正的并行条件下都出现. 下面的代码的输出结果为三个人都抢到了这台手机, 这就出现了多线程的中的并发问题，同时 MI 类中的 buy() 方法也被称为是线程不安全的 12345678910111213141516171819202122232425262728293031323334class MI &#123; private int MIX3 = 1; public boolean buy() throws InterruptedException &#123; if (MIX3 &gt; 0) &#123; Thread.sleep(1000);//模拟交接手续耗时 MIX3--; System.out.println("抢到了"); return true; &#125; else &#123; System.out.println("没货了"); return false; &#125; &#125;&#125;public static void main(String[] args) &#123; MI mi = new MI(); Runnable buy = new Runnable() &#123; @Override public void run() &#123; try &#123; mi.buy(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;; Thread t1 = new Thread(buy); Thread t2 = new Thread(buy); Thread t3 = new Thread(buy); t1.start(); t2.start(); t3.start();&#125; 我们可以通过在方法前加上synchronized关键字来是一个线程不安全的方法变为同步方法，当然安全就意味着效率的损失，所以我们也可以用同步块，仅使一部分代码变为同步 同步块synchronized(引用类型){注意作为锁的对象要保证引用不变，即为同一个对象} 同步方法 静态代理 真实角色 代理角色（持有真实角色的引用） 二者实现相同的接口 比如当你结婚时，婚庆公司可以作为一个代理角色，帮助你结婚，但真正结婚的仍然是你，也就是说你是真实角色，而婚庆公司是代理角色，静态代理的好处就是，作为真实角色的你只需要关注最核心的事，也就是‘结婚’，其它的工作都可以交由代理角色处理 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Main &#123; public static void main(String[] args) &#123; You you = new You();//真实对象 ProxyCompany proxy = new ProxyCompany(you);//代理对象 proxy.merry(); &#125;&#125;/***二者要实现的相同的接口*/interface Merry &#123; void merry();&#125;class You implements Merry &#123; @Override public void merry() &#123; System.out.println("你和嫦娥结婚了"); &#125;&#125;class ProxyCompany implements Merry &#123; You you;//代理对象要持有真实对象引用 public ProxyCompany() &#123; &#125; public ProxyCompany(You you) &#123; this.you = you; &#125; @Override public void merry() &#123; before(); you.merry(); after(); &#125; private void before()&#123; System.out.println("布置猪窝"); &#125; private void after()&#123; System.out.println("闹猪窝"); &#125;&#125; 而动态代理模式唯一的区别就是代理类是在运行过程中动态创建的，实现的功能是一样的至于为什么要讲静态代理模式，不难发现 Runnable 即为真实对象和代理对象同时实现的接口，Thread 为代理类, Thread 构造方法传入的参数即为真实对象.]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java——异常处理]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F2019-11-03-Java%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[Java——异常 异常不是编译时的错误(Error)，异常是运行时错误(Exception) 异常处理流程 代码出现错误后，它会先在原函数代码内部寻找是否有try catch语句，如果没有，则找到调用这个函数的函数内部寻找，如果还没有就会交给java虚拟机，虚拟机会直接结束掉程序，返回异常信息.如果异常交由 JVM 处理，JVM 会结束掉程序，并将异常信息输出到日志中，在 Android 上体现为 App 闪退。为了提高用户体验，我们要尽可能的处理可能发生的异常. image 异常处理 try catch 123456789101112131415public BufferedReader readFile(String path) &#123; /*打开path指定路径下的文件 * 可能抛出的异常 FileNotFoundException 文件不存在 */ FileInputStream fis = null; try &#123; //可能出现错误的代码块 fis = new FileInputStream(path); &#125; catch (FileNotFoundException e) &#123; //catch 可能出现的异常 e.printStackTrace();//打印异常信息(函数调用栈) &#125; BufferedReader brd = new BufferedReader(new InputStreamReader(fis)); return brd; &#125; throws如果你不想自己处理可能发生的异常，throws 可以将异常抛给调用该方法的方法进行处理，如果是 main 方法，再抛出时就会交由虚拟机处理. 12345public BufferedReader readFile(String path) throws FileNotFoundException &#123; FileInputStream fis = new FileInputStream(path); BufferedReader brd = new BufferedReader(new InputStreamReader(fis)); return brd; &#125; 异常的分类 image 如果抛出的异常为RuntimeException的子类，那么可以不进行捕获处理，如果是Exception的其它子类那么必须进行捕获处理，如果未进行捕获处理，但只要没有调用此方法，依然可以正常运行.根据，如果你不能确定抛出的的异常类型，则可以 catch 它们的父类型 1234567try &#123; //可能出现错误的代码块 fis = new FileInputStream(path);&#125; catch (Exception e) &#123; //catch 可能出现的异常 e.printStackTrace();//打印异常信息(函数调用栈)&#125; 自定义异常 我们可以根据不同的业务需求，选择不同的父类，如 RuntimeException，Exception … 1234567891011class LessMoneyException extends RuntimeException &#123; public LessMoneyException(String s) &#123; super(s); &#125;&#125;class TooMuchMoneyException extends Exception &#123; public TooMuchMoneyException(String s) &#123; super(s); &#125;&#125; 当我们在发现代码执行过程中出现错误时，我们可以选择不去处理这个错误，而是throw(抛出)一个异常，让调用该函数的上下文来处理这个错误，这么做的原因通常是你再将自己实现的函数封装起来，供给他人使用，那么最好的办法不是自己处理异常，而是将异常抛给使用者，让他根据具体情况来处理错误. 1234567public int foo2(ArrayList&lt;Integer&gt; list)&#123; if(list == null)&#123; throw new NullPointerException("list is null"); &#125;else &#123; return list.size(); &#125;&#125; 注意事项 对于一个代码块来说，内部的语句在执行过程中可能会抛出多种异常，我们可以捕获不同类型的异常，针对具体问题做出不同的处理 1234567891011121314public int foo1() &#123; String a = null; String b = "20"; String c = "0"; int result = -1; try &#123; result = Integer.valueOf(a) * Integer.valueOf(b) / Integer.valueOf(c); &#125; catch (NumberFormatException e) &#123; System.out.println("字符串转换整数错误,请检查被被转换字符串"); &#125; catch (ArithmeticException e) &#123; System.out.println("出现了算术异常,可能为除零错误"); &#125; return result;&#125; 当程序出现异常后，无论异常是否被处理，出现异常的代码后的语句都不再被执行,所以要注意因为异常导致的初始化及重置问题如果你在 IDE 中编写了如下代码，在 return 语句出会出现错误提醒，因为 try 代码块中为可能出现异常的语句，则其内的赋值语句不一定会被成功执行，并不能确保变量一定被初始化，同时如果 i 变量的赋值出现问题，j 的赋值语句完全不会被执行.Variable &#39;i&#39; might not have been initialized 1234567891011public double foo2() &#123; double i; double j; try &#123; i = Math.PI; j = 1; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return i;&#125; 可以使用finally来对状态进行统一管理，如资源清除，变量重置，关闭打开的文件等 1234567891011121314151617181920public void trans(int card1, int card2) &#123;//从card1向card2转账1000 int temp1 = card1, temp2 = card2; try &#123; card1 -= 1000; if (card1 &lt; 0) &#123; throw new LessMoneyException("钱太少了"); &#125; card2 += 1000; if (card2 &gt; 1001) &#123; throw new TooMuchMoneyException("要那么多钱干嘛"); &#125; &#125; catch (LessMoneyException e) &#123; e.printStackTrace(); &#125; catch (TooMuchMoneyException e) &#123; e.printStackTrace(); &#125; finally &#123; card1 = temp1; card2 = temp2; &#125;&#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java——集合类、泛型]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F2019-11-03-Java%E9%9B%86%E5%90%88%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Java集合类、泛型 导语 List、Set、Map lambda表达式、流式操作 泛型 一、导语​ 在第一节课中，我们讲了数组这一存储多个元素的数据结构，可以方便我们在编程中用一个对象来储存多个元素。然而在实际应用时，数组有一些缺点 —— 数组的长度一旦确定就无法更改。 增加和删除的效率低下。 根据内容查找元素速率慢。 ​ 事实上，对于很多实际开发中的数据结构，单纯用数组表示是比较麻烦且不易维护的，于是 Java 为我们提供了集合类来方便我们的操作。Java 集合类包含在 java.util 包下，所以在使用集合类前，要添加导包语句 import java.util.*; 二、List、Set、Map List ​ 一个 List 是一个元素有序的、可以重复、可以为 null 的集合（有时候我们也叫它“序列”）。Java 集合框架中最常使用的几种 List 的实现类是 ArrayList，LinkedList 和 Vector。ArrayList 的特点是可以动态添加元素，并像可以像数组一样通过下标访问对应的元素。我们接下来会介绍 ArrayList 的使用。 ArrayListArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。 12345678910111213141516171819202122232425262728293031323334public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; arrayList = new ArrayList&lt;&gt;(); //创建一个 ArrayList 对象 arrayList.add("1"); arrayList.add("12"); arrayList.add("123"); //向 arrayList 的最后添加元素 arrayList.add(0, "0"); //在 arrayList 的指定下标处插入元素 System.out.println(arrayList); String str = arrayList.get(1); //str = "1" //访问 arrayList 指定下标index对应的元素 int length = arrayList.size(); //length = 4 //返回 arrayList 中元素的个数 boolean isContain = arrayList.contains("123"); //isContain = true //判断 arrayList 中是否存在某个元素值 arrayList.remove(0);//将arrayList中下标为0的元素移除 System.out.println(arrayList); arrayList.remove("123");//将arrayList中"123"元素移除 System.out.println(arrayList); arrayList.clear();//将arrayList中所有元素移除 boolean isEmpty = arrayList.isEmpty();//isEmpty = true //判断 arrayList 是否为空 &#125; &#125; ( 注：1. 在创建 ArrayList对象时，尖括号中&lt;&gt;若不填任何类型或接口，则 ArrayList 可以容纳任何类型的元素，若规定了类型，则 ArrayList 只能容纳该类型的对象。 2. 在调用 ArrayList 的 get 和 remove 方法时，如果传进去的参数 index ≥ arrayList.size() 或 index &lt; 0 程序会停止运行，并抛出异常(Exception)。3. 在调用 ArrayList 的 remove 方法时(删除 arrayList 中的某个元素)， 如果原来的 ArrayList 中包含这个元素, ArrayList 会将这个元素删除并返回 true，若不包含，则直接返回false。） Set ​ Set 是对数学上集合概念的抽象。一个 Set 是一个元素无序的、不可以重复，可以为 null 的集合。与 List 不同的是，我们不能通过下标来对 Set 进行操作，且一个 Set 最多可含一个 null 元素，对于任意的非 null 元素 e1 和 e2，都满足e1.equals(e2) == false 。Set 有三个实现类 —— HashSet、LinkedHashSet、TreeSet。接下来以 HashSet 为例来介绍 Set 的用法。 HashSet HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等 ArrayList 中所有参数未涉及下标(index)的函数都可以类推到 Set 两个 Set 取并集 set1.addAll(set2)/取并集的结果为 set1 两个 Set 取交集 set1.retainAll(set2)//取交集的结果为 set1 Set 的遍历 123456789101112131415161718192021222324252627public class HashSetTest &#123; public static void main(String[] args) &#123; HashSet set = new HashSet&lt;String&gt;(); //初始化一个Set set.add("12"); set.add("1"); set.add("12"); set.add("123"); set.add("123");//重复的元素不会被添加 set.add("13"); set.add("23"); set.add("42"); Iterator iterator = set.iterator(); while (iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; //输出结果 //12 //1 //23 //123 //13 //42 //注：set是元素无序的 &#125;&#125; Map ​ Map 是对数学上映射概念的抽象。Map 中的每个元素都包含两部分 —— 键(key)和值(value)，可以通过键来获取值。在一个 Map 中，key 的值是不可以重复的。Map 有两个实现类 —— HashMap、TreeMap。接下来以 HashMap 为例来介绍 Map 的用法。 HashMap就像HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、 同时两个key的hashCode值也必须相等 clear 、size、isEmpty 函数和 ArrayList 类似。 123456789101112131415161718192021222324252627282930313233343536public class HashMapTest &#123; public static void main(String[] args) &#123; HashMap hashMap = new HashMap&lt;Integer, String&gt;();//初始化一个key类型为int,value类型为String的Map hashMap.put(1, "My key is 1."); hashMap.put(2, "My key is 2."); hashMap.put(3, "My key is 3."); //为map添加一个key为3，value为"My key is 3."的元素 System.out.println(hashMap.keySet()); // 输出结果：[1, 2, 3] // 返回了hashMap中所有key的集合（Set） System.out.println(hashMap.values()); // 输出结果：[My key is 1., My key is 2., My key is 3.] // 返回了hashMap中所有value的集合（Collection) System.out.println(hashMap.entrySet()); //输出结果：[1=My key is 1., 2=My key is 2., 3=My key is 3.] // 返回了hashMap中所有映射关系的集合（Set） HashMap&lt;Integer, String&gt; hashMap1 = new HashMap&lt;&gt;(); hashMap1.put(4, "My key is 4"); hashMap1.put(5, "My key is 5"); hashMap.putAll(hashMap1);//将 hashMap1 中的所有元素加到hashMap中 System.out.println(hashMap.remove(1)); // 输出结果：My key is 1. // 删除 hashMap 中key为1的元素，并返回key为1的value值 &#125;&#125; 队列队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念 三、lambda表达式、流式操作符Lambda表达式是Java SE 8中一个重要的新特性。lambda表达式允许你通过表达式来代替功能接口。 lambda表达式就和方法一样,它提供了一个正常的参数列表和一个使用这些参数的主体基本语法：(parameters) -&gt; expression或(parameters) -&gt;{ statements;} 简例： 1234567891011121314// 1. 不需要参数,返回值为 5 () -&gt; 5 // 2. 接收一个参数(数字类型),返回其2倍的值 x -&gt; 2 * x // 3. 接受2个参数(数字),并返回他们的差值 (x, y) -&gt; x – y // 4. 接收2个int型整数,返回他们的和 (int x, int y) -&gt; x + y // 5. 接受一个 string 对象,并在控制台打印,不返回任何值(看起来像是返回void) (String s) -&gt; System.out.print(s) 看看用法： 123456789101112interface Operation &#123; int operate(int a, int b);&#125;public static int operate(int a, int b, Operation o)&#123; o.operate(a, b);&#125;public static void main(String []args)&#123; Operation o = (int a, int b) -&gt; a - b; System.out.println(operate(3, 2, o)); //输出 1&#125; 用lambda表达式实现匿名内部类（Runnable 接口） 12345678910// 1.1使用匿名内部类 new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println("Hello world !"); &#125; &#125;).start(); // 1.2使用 lambda expression new Thread(() -&gt; System.out.println("Hello world !")).start(); 集合的流式操作：Stream ：Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulk data operation)。Stream API 借助于同样新出现的 Lambda表达式，极大的提高编程效率和程序可读性。示例： 1234567891011121314151617181920212223List&lt;StringClass&gt; list1 = new ArrayList&lt;&gt;();FirstData first = new FirstData();for (int i = 0; i &lt; first.getDataList().size(); i++)&#123; SecondData secondData = first.getDataList().get(i); //do something with second and firstData. for (int j = 0; j &lt; secondData.getDataList().size(); j++ )&#123; ThirdData third = secondData.getDataList().get(j); //give thirdList a filter if (third.getThirdData().startsWith(" "))&#123; list1.add(new StringClass(third.getThirdData())); &#125; //do something with third and thirdData &#125;&#125;first.getDataList() .forEach(it -&gt; it.getDataList() .stream() .filter(t -&gt; t.getThirdData().startsWith(" ")) .map(t -&gt; new StringClass(t.getThirdData())) .forEach(list1::add) ); 三、泛型​ Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。使用泛型，可以增加我们代码的复用性。 先看一个例子： 12345678List arrayList = new ArrayList&lt;/*String*/&gt;();arrayList.add("aaaa");arrayList.add(100);for(int i = 0; i&lt; arrayList.size();i++)&#123; String item = (String)arrayList.get(i); System.out.println("item = "+item);&#125; 毫无疑问，程序的运行结果会以崩溃结束：java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.StringArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。 我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。 123List&lt;String&gt; arrayList = new ArrayList&lt;String&gt;();...//arrayList.add(100); 在编译阶段，编译器就会报错 ​ 泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。​ 泛型类 泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。 和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。 实例 1234567891011121314151617181920212223242526272829public class Box&lt;T&gt; &#123; public Box(T t)&#123; this.t = t; &#125; private T t; public void set(T t) &#123; this.t = t; &#125; public T get() &#123; return t; &#125; public static void main(String[] args) &#123; Box&lt;Integer&gt; integerBox = new Box&lt;&gt;(); Box&lt;String&gt; stringBox = new Box&lt;&gt;(); integerBox.set(10); stringBox.set("天外天移动Android组"); System.out.println(integerBox.get()); System.out.println(stringBox.get()); //输出结果： //10 //天外天移动Android组 &#125;&#125; 定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 1234567891011121314151617181920212223public class Box&lt;T&gt; &#123; private T t; public Box(T t)&#123; this.t = t; &#125; public T get() &#123; return t; &#125; public static void main(String[] args) &#123; Box integerBox = new Box&lt;&gt;(10); Box stringBox = new Box&lt;&gt;("天外天移动Android组"); System.out.println(integerBox.get()); System.out.println(stringBox.get()); //输出结果： //10 //天外天移动Android组 &#125;&#125; 泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子 1234//定义一个泛型接口public interface Generator&lt;T&gt; &#123; public T next();&#125; 当实现泛型接口的类，传入泛型实参时： 1234567891011121314151617/** * 传入泛型实参时： * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt; * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。 * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型 * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。 */public class FruitGenerator implements Generator&lt;String&gt; &#123; private String[] fruits = new String[]&#123;"Apple", "Banana", "Pear"&#125;; @Override public String next() &#123; Random rand = new Random(); return fruits[rand.nextInt(3)]; &#125;&#125; 类型通配符在Box类的基础上，我们增加一个函数，将box之中的值打印出来： 1234//不是一个泛型方法public void showKeyValue1(Box&lt;?&gt; obj)&#123; Log.d("泛型测试","key value is " + obj.getKey());&#125; 此处的？就是类型通配符，可以让我们传入不同泛型对应的Box类。 泛型方法 你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。 下面是定义泛型方法的规则： 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的）。 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。 泛型方法体的声明不能是原始类型（比如int 、double、char）。 实例 1234567891011121314151617181920212223242526public class GenericsMethodTest &#123; /** * 这才是一个真正的泛型方法。 * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T * 这个T可以出现在这个泛型方法的任意位置. * 泛型的数量也可以为任意多个 * 如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123; * ... * &#125; */ private static&lt;T&gt; void printClassName(T t)&#123; System.out.println(t.getClass()); &#125; public static void main(String[] args) &#123; printClassName(1); printClassName(2.0); printClassName("twt"); //输出结果： //class java.lang.Integer //class java.lang.Double //class java.lang.String &#125;&#125; 泛型上下边界在使用泛型的时候，我们还可以为传入的泛型类型实参进行上下边界的限制，如：类型实参只准传入某种类型的父类或某种类型的子类。 为泛型通配符添加上边界，即传入的类型实参必须是指定类型的子类型 12345678910111213141516public void showKeyValue1(Box&lt;? extends Number&gt; obj)&#123; Log.d("泛型测试","key value is " + obj.getKey());&#125;Box&lt;String&gt; box1 = new Box&lt;String&gt;("11111");Box&lt;Integer&gt; box2 = new Box&lt;Integer&gt;(2222);Box&lt;Float&gt; box3 = new Box&lt;Float&gt;(2.4f);Box&lt;Double&gt; box4 = new Box&lt;Double&gt;(2.56);//这一行代码编译器会提示错误，因为String类型并不是Number类型的子类//showKeyValue1(box1);showKeyValue1(box2);showKeyValue1(box3);showKeyValue1(box4); 为方法的泛型添加上边界 1234567//在泛型方法中添加上下边界限制的时候，必须在权限声明与返回值之间的&lt;T&gt;上添加上下边界，即在泛型声明的时候添加//public &lt;T&gt; T showKeyName(Generic&lt;T extends Number&gt; container)，编译器会报错："Unexpected bound"public &lt;T extends Number&gt; T showKeyName(Box&lt;T&gt; container)&#123; System.out.println("container key :" + container.getKey()); T test = container.getKey(); return test;&#125; 参考文档 Java 集合深入理解（4）：List 接口 Set接口及其实现 Java Map 接口 Java泛型]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android knowledge</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简易微信开发白皮书]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F11%2F03%2F%E7%AE%80%E6%98%93%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E7%99%BD%E7%9A%AE%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[简易微信开发白皮书[TOC] 1. 软件概况展示1.1 功能展示（截图附于文末） 基础功能 1） 注册、登陆、登出(包含是否已注册、重名判断等) 2） 添加、删除好友 3） 好友列表展示 4） 实时的新消息提醒和收发消息（包含对是否好友，好友在线状态的判断） 5） 支持对文件，图片的发送和接收 拓展功能 6） 保存聊天记录 7） 实时弹窗提醒用户收到新消息，并展示发送方和消息预览 8） 缓存聊天内容，可以保存未读的聊天记录 9） 服务器主动向客户端推送信息（TCP长连接，模拟实现双工通信） 10） 使用token进行用户身份验证，除密码验证外提供多一层的安全保障 11） UI美化，消息气泡大小动态变化 12） 展示用户信息，如用户名，头像等 1.2 健壮性及异常情况处理展示1） 检测并阻止重复注册或登陆 2） 检测用户的在线状态 3） 检查用户的好友列表及好友关系 2. 软件整体系统架构分析2.1 整体：前后端分离 简易微信整体前后端分离 服务器的开发语言为 java，开发工具为 intelliJ Idea； 客户端的开发语言为 kotlin， 开发工具为 Android Studio。 服务器部署在本机，与各客户端采用socket连接，C/S模式。UML图如下： 2.2 服务器端：JDBC, Socket, Thread, PostgreSql 采用JDBC管理底层数据库，底层采用postgreSql数据库存储必要的信息 使用 java结合sql语句操作数据库，实现对信息的增删查改。 采用Socket连接实现与客户端的连接与通信，从而成为沟通客户端的中枢，典型的C/S。 采用多线程开启socket通信，使用统一的Server和Map进行管理 重写java的Tuple类，以实现服务器的多返回值 2.3 客户端：MVP、Fragment、Json 使用 kotlin开发，MVP技术架构。数据层(model)、数据处理层(presenter)、用户交互层(view)高度解耦，使得数据处理和用户交互更加优雅 主界面采用ViewPager+Fragment，可以轻松在各界面间滑动 每项操作都提供反馈，实时接收服务器消息 自定数据、协议格式，借鉴目前常用的Json格式 快速、稳定的图片传输 3. 自定义协议分析3.1 传输协议及格式简易微信server端采用TCP作为传输层协议，http作为应用层协议，并对http的协议格式和报文格式进行自定义修改，报文采用 json 格式数据文档实现server与client间的通信。 3.2 网络连接 服务器搭建在本地，监听12000端口，本机访问服务器使用 ip为127.0.0.1，其余客户端访问服务器时地址采用本机 ip。服务器程序会一直监听发起请求的客户端，与之保持连接状态，直到客户端主动断开连接。在此期间，服务器与客户端间的输入输出流将保持。需要注意的是，每次服务器重启会强制登出所有用户。 服务器可以接受并处理post请求，以json格式的数据返回请求结果及信息 3.3 部分自定义协议的接口文档（完整版太多了，附于文档末尾）1. 返回报文的body组成每次服务器返回的报文body都会包含以下信息： 1&#123; “code”:code, “msg”:”msg”, “type”:”type” &#125; 其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类 2. 用户注册接口路径为 ip/register 请求报文的body格式： 1&#123; “username”:”name”, “pwd”:”password” &#125; 返回报文的body格式： 1&#123; “code”:0, “msg”:”msg”, “type”:”register” &#125; 返回的code及msg： code msg 0 注册成功 -1 重复的用户名 3. 用户登陆接口路径为ip/login 请求报文的body格式： 1&#123; “username”:”name”, “pwd”:”password” &#125; 返回的body格式： 1&#123; “code”:0, “msg”:”msg”, “type”:”login”, “token”:12345 &#125; code及msg： code msg 0 OK 1 密码错误 2 已经在线了 -1 该用户尚未注册 4. 用户登出路径ip/logout 请求报文： 1&#123; “userName”:”name”, “token”:12345 &#125; 返回报文： 1&#123; “code”:0, “msg”:”msg”, “type”:” offline” &#125; code及msg： code msg 0 OK 1 已经离线了 2 token无效 -1 用户不存在 5. 获取好友列表路径ip/friends 请求报文： 1&#123; “username”:”name”, “token”:12345 &#125; 返回报文： 12&#123; “code”:0, “msg”:”msg”, “type”:” friends”, “friends”:[“friend1”,”friend2”] &#125; -- friends是一个jsonArray的数组 code及msg： code msg 0 OK 1 token无效 -1 用户尚未注册 6. 完整版自定义协议的接口文档附于本文档末尾3. 各部分实现技术细节分析3.1 服务器技术细节3.1.1 DataBeans 包 该包下存放登录、注册等各种不同请求的数据类，统一命名为XxxRequestBean,XxxResponseBean,如（CommonRequestBean, CommonResponseBean等） XxxRequestBean用于存储从请求报文中按格式解析出的信息，用于本地对数据库的操作 XxxResponseBean用于存储本地对数据库增删查改后的结果，用于向发起请求的客户端返回信息以及向需要转发的客户端转发消息 值得一提的是在该包内抽象出了JsonToObject和ObjectToJson两个接口，实现通信报文中json格式数据与服务器中java对象类型数据的项目转化，提高了代码复用性和可读性。 3.1.2 HttpServer.java 该类持有server服务器的对象，并持有userMap等数据结构保存用户的id和对应的socket通信，从而实现服务器向特定用户主动推送消息，实现好友申请和收到消息的即时提醒 在此类使用多线程处理每个独立的socket通信，避免相互之间的干扰，便于管理，也能实现多用户登录 此类中的initDataBase方法使用JDBC连接数据库，若是数据库不存在时则主动建立数据库，具有良好的健壮性 3.1.3 ServerThread.java 该类定义每个独立的线程中socket通信的动作，其中包括： 重载Thread的run方法解析自定义的请求报文，得到请求种类（如GET）和请求的url以及请求报文body，传递给post函数 post函数得到报文，根据header中的url对各个功能函数进行调用，进行相应处理后得到应返回的数据。并通过各Bean类的格式化函数将信息格式化为合法的报文进行返回 使用response返回发出请求的客户端，使用sendInfos向被请求的客户端主动推送消息 regist， login等功能函数从报文的body中得到用户名，身份验证token等信息，用于实现简易微信的各项功能，如： registe 从报文中获得用户名和密码，在数据库中进行查询，进行注册或返回异常（如重复用户名）等操作 login ，logout时对身份token进行验证后，更新数据库并返回用户的请求状态，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息 getFriends时，根据用户名查询数据库，进行数据更新并返回好友列表 发送消息时，客户端请求sendMsg，向服务器发出消息及接收方和发送时间；服务器接到该报文后解析出被发送方，然后通过sendToFriend查询数据库得到被发送方的信息是否合法，该用户是否在线等，并通过Map得到该用户对应的socket连接。若是均符合条件，调用sendTo对消息进行转发，主动发给消息接收方 发送图片和文件类型的消息流程基本一致，函数分别为sendPicsToFriend, sendPics和sendFileToFriends, sendFile 添加好友与发送消息时类似，用户将请求发送给服务器，然后由服务器通过被请求方对应的socket连接进行转发。其中makeFriends进行数据库查询判断信息是否合法，并得到被请求方对应的socket连接，然后使用sendFriendRequest由服务器主动向被请求方转发好友请求 发送好友申请的结果流程与申请添加好友一致，函数为makeFriendsCheck和sendResquestRes 删除好友deleteFriend时，用户向服务器发出请求，服务器通过deleteFriend处理数据库中的好友关系表，实现对数据的更新，并返回给用户操作状态 发送图片和文件时，使用Socket的文件输入输出流FileInputStream和FileOutputStream，进行字节流传输，以二进制流的方式进行传输 3.1.4 Tuple.java 重写java的Tuple类，以实现服务器某些功能函数要求的多返回值情况 3.2 客户端技术细节3.2.1NetService.kt 该包下存放登录、注册等各种不同请求方法，和存放socket 该文件下存放所有网络请求相关的方法，其中包括 loginService，进行登录请求同时接收服务器的回复，如“已经注册”“注册成功”“已经在线”“密码错误”“登出成功”等信息 logoutService登出请求同时接收服务器的回复 regiService注册请求同时接收服务器的回复 friendsService接收好友列表同时接收服务器的回复 deleteService删除好友同时接收服务器的回复 makefriendsService添加好友同时接收服务器的回复 confirmRequestService确认好友信息同时接收服务器的回复 sendPictureService发送照片同时接收服务器的回复 sendMessageService发送消息同时接收服务器的回答 3.2.2 LoginBean.kt 在该包下保存用于保存服务器请求的数据类 命名统一为XXBean 3.2.3Items.kt 在该包下保存RecyclerView解耦之后的各种item 使用RecyclerDSL 3.2.4UISupport.kt 用于制作沉浸式状态栏 3.2.5TabFragment 提供了管理三个页面的三个方法： 管理聊天界面：setTalkList 管理好友界面：setFriendList 管理设置：setMineList 3.2.6ItemAdapter 用于管理聊天界面的RecyclerView的消息展示 通过addItem方法直接添加子项 3.2.7LoginActivity 登陆界面，监听两个EditText和一个LoginButton 3.2.8MainActivity 应用的总界面，有三个Fragment，分别为消息列表，好友列表和个人信息 使用Handler进行回调，进行线程间通信 外层是Viewpager，可以轻松实现页面间滑动 3.2.9TalkActivity 聊天界面 点九图实现气泡 使用Handler进行回调 可以发送消息、图片、文件 增加文件选择器，可从本地选择文件 3.2.10 MVP架构 对数据层（Model）、处理层（Presenter）和交互层（View）进行解耦 便于维护和根据特定需求进行修改 3.3 数据库技术细节数据库中采用sql语句建立两个表，分别存储用户信息及用户好友关系。 12345678910111213CREATE TABLE IF NOT EXISTS UserData( userName VARCHAR PRIMARY KEY, --用户名，作为主键 ID INTEGER, --用户id passWord VARCHAR, --密码 isOnline INTEGER, --用户在线状态 token INTEGER); --用于身份验证的tokenCREATE TABLE IF NOT EXISTS UserFriends( userName VARCHAR, --用户名 friendName VARCHAR, --用户的好友名 ID INTEGER PRIMARY KEY); --用户id -- 主键的意义在于快速检索每个用户对应的socket 其中userName存储用户名， ID作为与每个用户对应的Socket通信的标识，isOnline存储用户的在线离线状态，便于服务器在收到消息和好友申请时的判断和处理。 4. 难点重点回顾(以下代码均为示意，并非源代码)4.1 服务器端 最早时未使用统一的Server和 clientMap管理Socket连接，导致各个用户的连接之间出现数据相互影响的情况，后通过引入多线程处理消息和Map统一管理来解决这一问题 1234567public static Map&lt;Integer, Socket&gt; userMap = new HashMap&lt;&gt;();try&#123; client = this.server.accept(); new Thread(new ServerThread(client)).start();&#125; catch (IOException e) &#123; e.printStackTrace();&#125; 由于TCP短连接的问题，导致连接不稳定，经常意外中断，后通过持续监听的心跳机制实现TCP长连接解决了该问题 1234while(true)&#123; assert server != null; client = this.server.accept();&#125; 转发消息时经常误判需要被发送的socket并出现wirterror，后来通过封装为函数，通过传参的方式确定socket和报文格式解决 123456789101112131415String commonMSG = "HTTP/1.1 %code %msg\r\n" + "Content-Type: application/json;charset=utf-8\r\n" + "Connection: keep-alive\r\n" + "Content-Length: %type_body\r\n\r\n"; private void sendInfos(Socket infoClient, String json) &#123; try &#123; String res = json + "\n"; OutputStream out = client.getOutputStream(); out.write(res.getBytes()); out.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; 5. 完整版接口文档1. 返回报文的body组成每次服务器返回的报文body都会包含以下信息： 1&#123; “code”:code, “msg”:”msg”, “type”:”type” &#125; 其中code表示请求的结果码，msg表示返回的具体信息，type表示请求的种类 2. 用户注册接口路径为 ip/register 请求报文的body格式： 1&#123; “username”:”name”, “pwd”:”password” &#125; 返回报文的body格式： 1&#123; “code”:0, “msg”:”msg”, “type”:”register” &#125; 返回的code及msg： code msg 0 注册成功 -1 重复的用户名 3. 用户登陆接口路径为ip/login 请求报文的body格式： 1&#123; “username”:”name”, “pwd”:”password” &#125; 返回的body格式： 1&#123; “code”:0, “msg”:”msg”, “type”:”login”, “token”:12345 &#125; code及msg： code msg 0 OK 1 密码错误 2 已经在线了 -1 该用户尚未注册 4. 用户登出路径ip/logout 请求报文： 1&#123; “userName”:”name”, “token”:12345 &#125; 返回报文： 1&#123; “code”:0, “msg”:”msg”, “type”:” offline” &#125; code及msg： code msg 0 OK 1 已经离线了 2 token无效 -1 用户不存在 5. 获取好友列表路径ip/friends 请求报文： 1&#123; “username”:”name”, “token”:12345 &#125; 返回报文： 12&#123; “code”:0, “msg”:”msg”, “type”:” friends”, “friends”:[“friend1”,”friend2”] &#125; -- friends是一个jsonArray的数组 code及msg： code msg 0 OK 1 token无效 -1 用户尚未注册 6. 发送加好友请求路径ip/makefriends 请求报文： 1&#123; “username”:”name”, “token”:12345, “newfriend”:”newfriend” &#125; 返回报文： 1&#123; “code”:0, “msg”:”msg”, “type”:” makefriend”, &#125; code及msg： code msg 0 请求发送成功 1 token 无效 2 已经是好友了 3 目标用户不存在 -1 用户尚未注册 -2 目标用户不在线 请求只有在对方在线时在允许发送 7. 回复好友请求路径ip/result 请求报文： 12345&#123; “from”:”A”, “to”:”B”, “token”:12345, “status”:1 &#125;-- from 代表当前用户的用户名-- to 代表接受方的用户名-- status 代表回复的结果-- token用于身份验证，保证安全性 返回报文： 1&#123; “code”:0, “msg”:”msg”, “type”:” result” &#125; code及msg; code msg 0 成功 1 token无效 2 已经是好友了 3 目标用户不存在 -1 用户尚未注册 -2 目标用户不在线 8. 服务器端转发好友请求报文格式： 1&#123; “code”:0, “msg”:”msg”, “type”:” friendrequest”, “from”:”from” &#125; 服务器收到用户发出的好友申请时，会主动向被申请方发出该消息 9. 服务器端转发好友请求的回复结果报文格式： 1&#123; “code”:0, “msg”:”msg”, “type”:” makefriendres” &#125; 服务器收到被申请方的回复时，会主动向申请方发出该消息 10. 发送消息路径ip/sendmsg 报文格式： 1&#123; “username”:”name”, “token”:12345, “to”:”to”, “msg”:”data” , "time":"time"&#125; 返回格式： 1&#123; “code”:0, “msg”:”msg”, “type”:” sendmsgres” &#125; code及msg： code msg 0 发送成功 1 token无效 2 没有这个好友 -1 该用户尚未注册 -2 当前用户不在线 11. 服务器转发消息报文格式： 1&#123; “code”:0, “msg”:”msg”, “type”:” msg”, “from”:”from” , "time":"time"&#125; 当服务器收到客户端发送的消息时，该 json 由服务器主动发出。其中 code 总是 0，from 表示发送方用户名，msg 为消息本体。 12. 发送文件路径ip/sendFile 报文格式 123&#123; “code”:0, “msg”:”msg”, “type”:” msg”, “from”:”from” , "to": "to", "time":"time"， "filename": "filename"&#125; - msg 发送文件转码的字节流- filename 发送文件名 返回格式 1&#123; “code”:0, “msg”:”msg”, “type”:” sendfile” &#125; code msg 0 发送成功 1 token无效 2 没有这个好友 -1 该用户尚未注册 -2 当前用户不在线 13. 服务器主动转发文件发送报文 123&#123; “code”:0, “msg”:”msg”, “type”:” msg”, “from”:”from” , "time":"time", "filename": "filename"&#125; - msg 发送文件转码的字节流- filename 发送文件名 14. 删除好友路径ip/delete 报文格式 1&#123; “username”:”name”, “token”:12345, “friendname”:”friendname” &#125; 返回格式 1&#123; “code”:0, “msg”:”msg”, “type”:” delete” &#125; code msg 0 删除成功 1 token无效 6. 运行截图由于Markdown排版问题可能略丑请见谅 1.登陆及注册界面默认 未注册 注册时用户名重复 2.通讯录默认 添加好友 添加好友时目标好友离线 目标好友不存在 3.聊天界面默认 聊天对象不是好友 4.个人页面]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android development</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初始卷积神经网络（CNN）]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F09%2F02%2F%E5%88%9D%E8%AF%86%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%88CNN%EF%BC%89%2F</url>
    <content type="text"><![CDATA[一、基础结构CNN和之 前介绍的神经网络一样，可以像乐高积木一样通过组装层来构建。不过， CNN中新出现了卷积层（Convolution层）和池化层（Pooling层）。此外，各层中传递的数据是有形状的数据（比如，3维数据）靠近输出的层中使用了之前 的“ Affine - ReLU”组合。此外，最后的输出层中使用了之前的“Affine - Softmax”组合。这些都是一般的CNN中比较常见的结构。 二、卷积层2.1 卷积层的优势在全连接层中，数据的形状被忽视了。以图像输入为例子，图像通常是高、长、通道方向上的3维形状。但是，向全连接层输入时，需要将3维数据拉平为1维数据。前面提到的使用 了MNIST数据集的例子中，输入图像就是1通道、高28像素、长28像素的（1, 28, 28）形状，但却被排成1列，以784个数据的形式输入到最开始的 Affine层。而卷积层可以保持形状不变。当输入数据是图像时，卷积层会以3维数据的形式接收输入数据，并同样以3维数据的形式输出至下一层。因此可以提取出邻近的像素为相似的值、RBG的各个通道之间分别有密切的关联性、相距 较远的像素之间没有什么关联等值得提取的本质模式，利用与数据形状相关的信息。 2.2 卷积运算（图像处理中的滤波器运算）2.2.1 卷积运算基本过程先来看一个经过卷积运算的结果对于输入数据，卷积运算以一定间隔滑动滤波器的窗口并应用。这里所说的窗口是指下图中灰色的3×3的部分。如下图所示，将各个位置上滤波器的元素和输入的对应元素相乘，然后再求和（有时将这个计算称为乘积累加运算）。然后，将这个结果保存到输出的对应位置。将这个过程在所有位置都进行一遍，就可以得到卷积运算的输出。 如果有偏置，则在卷积运算结果的各个位置都加上偏置的值。 2.2.2 填充在卷积神经网络中引入了填充和步幅等特殊概念，这里我们来介绍一下填充。在进行卷积层的处理之前，有时要向输入数据的周围填入固定的数据（比如0等），这称为填充（padding），是卷积运算中经常会用到的处理。比如， 在下图的例子中，对大小为(4, 4)的输入数据应用了幅度为1的填充。“幅度为1的填充”是指用幅度为1像素的0填充周围。可以看到，通过填充，大小为(4, 4)的输入数据变成了(6,6)的形状。 然后，应用大小为(3, 3)的滤波器，生成了大小为(4,4)的输出数据。这个例子中将填充的值设成了1，不过填充的值也可以设置成2、3等任意的整数。在图该例子中，如果将填充设为2，则输入数据的大小变为(8,8)；如果将填充设 为3，则大小变为(10, 10)。 使用填充主要是为了调整输出的大小。比如，对大小为(4, 4)的输入数据应用(3,3)的滤波器时，输出大小变为(2, 2)，相当于输出大小比输入大小缩小了2个元素。在反复进行多次卷积运算的深度网络中,如果每次进行卷积运算都会缩小空间，那么在某个时刻输出大小就有可能变为1，导致无法再应用卷积运算。 2.2.3 步幅介绍完填充，再来介绍一下步幅。步幅是应用滤波器的位置间隔，以下是步幅为2的情况。 2.2.4 填充，步幅和输出结果的瓜系增大步幅后，输出大小会变小。而增大填充后，输出大小会变大。 如果将这样的关系写成算式，会如何呢？我们看一下对于填充和步幅，如何计算输出大小。 这里，假设输入大小为(H,W)，滤波器大小为(FH,FW)，输出大小为 (OH,OW)，填充为P，步幅为S。此时，输出大小可通过下列式子计算。 $$ OH = \frac{H+2P-FH}{S} + 1 $$ $$ OW = \frac{H+2P-FW}{S} + 1 $$ 我们来思考一个问题，为什么卷积运算是有效的？依然用例子来说明，比如我们有一个4*4的图像，我们设计两个卷积核，看看运用卷积核后图片会变成什么样。从结果可以看出，通过第一个卷积核计算后的特征图是一个三维数据，在第三列的绝对值最大，说明原始图片上对应的地方有一条垂直方向的特征，即像素数值变化较大；而通过第二个卷积核计算后，第三列的数值为0，第二行的数值绝对值最大，说明原始图片上对应的地方有一条水平方向的特征，即像素值数值变化较大。这样就提取出了大致的两个特征，通过在更深层次的网络中设置更多更巧妙的卷积核，我们就可以得到更多更准确的特征。我们设计的卷积核分别能够提取，或者说检测出原始图片的特定的特征。所以实际上就可以把卷积核理解为特征提取器，我们不需要手动去选取特征，只用设计好卷积核的尺寸，数量和滑动的步长就可以让它自己去训练了。同时，由于多个神经元可以共享卷积核，对于高位数据的处理将会变得非常简单。留下几个小问题供大家思考： 1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？ 2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ 3.步长的向右和向下移动的幅度必须是一样的吗？ 在最后我将给出这些问题的答案。 2.2.5 多通道图的卷积运算这里先介绍单通道图和多通道图的概念（一）：单通道图俗称灰度图，每个像素点只能有有一个值表示颜色，它的像素值在0到255之间，0是黑色，255是白色，中间值是一些不同等级的灰色。（也有3通道的灰度图，3通道灰度图只有一个通道有值，其他两个通道的值都是零）。（二）:三通道图每个像素点都有3个值表示 ，所以就是3通道。也有4通道的图。例如RGB图片即为三通道图片，RGB色彩模式是工业界的一种颜色标准，是通过对红(R)、绿(G)、蓝(B)三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的，RGB即是代表红、绿、蓝三个通道的颜色，这个标准几乎包括了人类视力所能感知的所有颜色，是目前运用最广的颜色系统之一。总之，每一个点由三个值表示。 之前的卷积运算的例子都是以有高、长方向的2维形状的单通道图为对象的。但是， 图像是3维数据，除了高、长方向之外，还需要处理通道方向。这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。这里以3通道的数据为例， 展示了卷积运算的结果。和2维数据时相比，可以发现纵深方向（通道方向）上特征图增加了。通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。需要注意的是，在3维数据的卷积运算中，输入数据和滤波器的通道数要设为相同的值。从上图可知，每个卷积核输出一张特征图，而多个卷积核输出的特征图汇集在一起，传递给下一层，这就是CNN的处理流。最后再看看一看卷积运算中的处理流是什么亚子。 三、 池化讲了这么久的卷积，终于来到了池化（pooling）层池化是缩小高、长方向上的空间的运算。比如，如图所示，进行将 2×2的区域集约成1个元素的处理，缩小空间大小。一般来说，池化的窗口大小会 和步幅设定成相同的值。 除了MaxPooling之外，还有AveragePooling等。相对于MaxPooling是从目标区域中取出最大值，AveragePooling则是计算目标区域的平均值。 在图像识别领域，主要使用MaxPooling。 那么问题来了，为什么MaxPooling能起到效果呢MaxPooling意义在哪里？如果我们只取最大值，那其他的值被舍弃难道就没有影响吗？不会损失这部分信息吗？如果认为这些信息是可损失的，那么是否意味着我们在进行卷积操作后仍然产生了一些不必要的冗余信息呢？ 其实从上文分析卷积核为什么有效的原因来看，每一个卷积核可以看做一个特征提取器，不同的卷积核负责提取不同的特征，我们例子中设计的第一个卷积核能够提取出“垂直”方向的特征，第二个卷积核能够提取出“水平”方向的特征，那么我们对其进行MaxPooling操作后，提取出的是真正能够识别特征的数值，其余被舍弃的数值，对于我提取特定的特征并没有特别大的帮助。在进行后续计算时，就减小了特征图的尺寸，从而减少参数，达到减小计算量，缺不损失效果的情况。 这也意味着MaxPooling对微小的位置变化具有健壮性，输入数据发生微小偏差时，池化仍会返回相同的结果,池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。 不过并不是所有情况MaxPooling的效果都很好，有时候有些周边信息也会对某个特定特征的识别产生一定效果，那么这个时候舍弃这部分“不重要”的信息，就不划算了。所以还要具体情况具体分析，如果加了Max Pooling后效果反而变差了，不如把卷积后不加MaxPooling的结果与卷积后加了MaxPooling的结果输出对比一下，看看MaxPooling是否对卷积核提取特征起了反效果。 3.1 Flatten层 &amp; Fully Connected Layer 到这一步，其实我们的一个完整的“卷积部分”就算完成了，如果想要叠加层数，一般也是叠加“Conv-MaxPooing”,通过不断的设计卷积核的尺寸，数量，提取更多的特征，最后识别不同类别的物体。做完MaxPooling后，我们就会把这些数据“拍平”，丢到Flatten层，然后把Flatten层的output放到full connected Layer里，采用softmax对其进行分类。 四、 CNN的可视化学习前的滤波器是随机进行初始化的，所以在黑白的浓淡上没有规律可循，但学习后的滤波器变成了有规律的图像。我们发现，通过学习，滤波器被更新成了有规律的滤波器，比如从白到黑渐变的滤波器、含有块状区域（称为blob）的滤波器等。如果要问右边的有规律的滤波器在“观察”什么，答案就是它在观察边缘（颜色变化的分界线）和斑块（局部的块状区域）等。比如，左半部分为白色、右半部分为黑色的滤波器的情况下，如图所示，会对垂直方向上的边缘有响应。 五、问题小结最后是上面给大家留下的问题1.卷积核的尺寸必须为正方形吗？可以为长方形吗？如果是长方形应该怎么计算？ 2.卷积核的个数如何确定？每一层的卷积核的个数都是相同的吗？ 3.步长的向右和向下移动的幅度必须是一样的吗？ 下面的想法，可以作为参考： 1.卷积核的尺寸不一定非得为正方形。长方形也可以，只不过通常情况下为正方形。如果要设置为长方形，那么首先得保证这层的输出形状是整数，不能是小数（一些框架会对小数进行四舍五入处理，一些会引起报错）。如果你的图像是边长为 28 的正方形。那么卷积层的输出就满足 [ (28 - kernel_size)/ stride ] + 1 ，这个数值得是整数才行，否则没有物理意义。池化层同理。FC 层的输出形状总是满足整数，其唯一的要求就是整个训练过程中 FC 层的输入得是定长的。如果你的图像不是正方形。那么在制作数据时，可以缩放到统一大小（非正方形），再使用非正方形的卷积核来使得卷积层的输出依然是整数。总之，撇开网络结果设定的好坏不谈，其本质上就是在做算术应用题：如何使得各层的输出是整数。 2.由经验确定。通常情况下，靠近输入的卷积层，譬如第一层卷积层，会找出一些共性的特征，如手写数字识别中第一层我们设定卷积核个数为5个，一般是找出诸如”横线”、“竖线”、“斜线”等共性特征，我们称之为basic feature，经过池化后，在第二层卷积层，设定卷积核个数为20个，可以找出一些相对复杂的特征，如“横折”、“左半圆”、“右半圆”等特征，越往后，卷积核设定的数目越多，越能体现的特征就越细致，就越容易分类出来。比如你想分类出“0”的数字，你看到这个特征，能推测是什么数字呢？只有越往后，检测识别的特征越多，试过才能慢慢能识别出这几个特征，那么我就能够确定这个数字是“0”。 3.有stride_w和stride_h，表示左右步长和上下步长。如果用stride，则表示stride_h=stride_w=stride。]]></content>
      <categories>
        <category>neural network</category>
      </categories>
      <tags>
        <tag>CNN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[神经网络的反向误差传播]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F08%2F30%2F%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%8F%8D%E5%90%91%E8%AF%AF%E5%B7%AE%E4%BC%A0%E6%92%AD%2F</url>
    <content type="text"><![CDATA[一、一般的全连接神经网络结构1.1 “层”的概念每个“层”在神经网络中被实现为一个类，作为神经网络中的功能单位，类中定义了此层接受的输入，运算和输出。比如，负责激活函数的层就是Sigmoid层，ReLU层等等，负责矩阵相乘的就是上次提到的Affine层。以Affine层和ReLU层为例 123456789101112131415161718AffineX = np.random.rand(2) # 输入W = np.random.rand(2，3) # 权重参数B = np.random.rand(3) # 偏置Y = np.dot(X, W) + B # 得到相乘结果class Relu: def __init__(self): self.mask = None # mask这个变量在反向传播时很重要，稍后会提到 def forward(self, x): # 正向传播 self.mask = (x &lt;= 0) out = x.copy() out[self.mask] = 0 return out def backward(self, dout): # 反向传播 dout[self.mask] = 0 dx = dout return dx 这里Affine中的 X、W、B 分别是形状为 (2,)、(2,3)、(3,) 的多维数组。这样一来，神经元的加权和可以用 Y = np.dot(X, W) + B 计算出来。然后，Y 经过激活函数转换后，传递给下一层。这就是神经网络正向传播的流程。调用激活层中的 forward 正向传播。 二、正向传播时的梯度下降法在正向传播中，采用数值微分法求梯度在每一层，采用数值微分法分别求损失函数对于该层的各个权重参数的偏导数，组合成梯度，然后令各参数向梯度下降的方向更新。代码其实很好懂，简直就像大白话，这里举一个简单的例子。 123456789101112131415161718192021222324# 求梯度def numerical_gradient(f, x): # x为传入的各参数的数组/多维数组 h = 1e-4 # 0.0001 grad = np.zeros_like(x) # 生成和x形状相同的数组 for idx in range(x.size): tmp_val = x[idx] # f(x+h)的计算 x[idx] = tmp_val + h fxh1 = f(x) # f(x-h)的计算 x[idx] = tmp_val - h fxh2 = f(x) # 组合为梯度 grad[idx] = (fxh1 - fxh2) / (2*h) x[idx] = tmp_val # 还原值 return grad# 梯度下降法def gradient_descent(f, init_x, lr=0.01, step_num=100): x = init_x for i in range(step_num): grad = numerical_gradient(f, x) x -= lr * grad return x 梯度下降法的函数的参数中，f 为我们选用的损失函数，x为各层传入的参数数组，lr为学习率，也就是参数每次更新的程度，step_num为更新的轮数。 这就是通过数值微分法计算损失函数关于权重参数的梯度。数值微分虽然简单，也容易实现，但缺点是计算上比较费时间。所以我们将学习一个能够高效计算权重参数的梯度的方法——误差反向传播法。 三、误差反向传播法3.1 计算图3.1.1 利用计算图求解计算图解题的情况下，需要按如下流程进行 构建计算图。 在计算图上，从左向右进行计算。（正向传播） 现在我们尝试用计算图求解简单的问题问题1： 太郎在超市买了2个100元一个的苹果，消费税是10%，请计算支付金额。 问题2：太郎在超市买了2个苹果、3个橘子。其中，苹果每个100元， 橘子每个150元。消费税是10%，请计算支付金额。 3.1.2 局部计算计算图的特征是可以通过传递“局部计算”获得最终结果。“局部”这个 词的意思是“与自己相关的某个小范围”。局部计算是指，无论全局发生了什么， 都能只根据与自己相关的信息输出接下来的结果。我们用一个具体的例子来说明局部计算。比如，在超市买了2个苹果和其他很多东西。此时，可以画出如图3-3所示的计算图。 如图3-3所示，假设（经过复杂的计算）购买的其他很多东西总共花费4000元。这里的重点是，各个节点处的计算都是局部计算。这意味着，例如苹果和其他很多东西的求和运算（4000 + 200 → 4200）并不关心4000这个数字是如何计算而来的，只要把两个数字相加就可以了。换言之，各个节点处只需进行与自己有关的计算（在这个例子中是对输入的两个数字进行加法运算），不用考虑全局。综上，计算图可以集中精力于局部计算。无论全局的计算有多么复杂， 各个步骤所要做的就是对象节点的局部计算。虽然局部计算非常简单，但是通过传递它的计算结果，可以获得全局的复杂计算的结果。 3.1.3 为何使用计算图实际上，使用计算图最大的原因是，可以通过反向传播高效计算导数。 在介绍计算图的反向传播时，我们再来思考一下问题1。问题1中，假设我们想知道苹果价格的上涨会在多大程度上影响最终的支付金额，即求“支付金额关于苹果的价格的导数”。设苹果的价格为 x，支付金额为 L，则相当于求 $ \frac{dL}{dX} $。先来看一下结果，如图3-4所示，可以通过计算图的反向传播求导数（关于如何进行反向传播，接下来马上会介绍）。如图3-4所示，反向传播使用与正方向相反的箭头（粗线）表示。反向传播传递“局部导数”，将导数的值写在箭头的下方。在这个例子中，反向传播从右向左传递导数的值（1→1.1→2.2）。从这个结果中可知，“支付金额关于苹果的价格的导数”的值是2.2 “支付金额关于消费税的导数”“支付金额关于苹果的个数的导数”等也都可以用同样的方式算出来。并且, 计算中途求得的导数的结果（中间传递的导数）可以被共享，从而可以高效地计算多个导数。综上，计算图的优点是，可以通过正向传播和反向传 播高效地计算各个变量的导数值。 3.2 链式法则3.2.1 计算图的反向传播话不多说，让我们先来看一个使用计算图的反向传播的例子。假设存在 y = f(x)的计算，这个计算的反向传播如图3-4所示。 如图所示，反向传播的计算顺序是，将信号E乘以节点的局部导数 （ $\frac{dy}{dx}$），然后将结果传递给下一个节点。这里所说的局部导数是指正向传播中$y = f(x) $的导数，也就是y关于x的导数（ $\frac{dy}{dx}$）。把这个局部导数乘以上游传过来的值（本例中为E）， 然后传递给前面的节点。 3.2.2 链式法则链式法则是关于复合函数的导数的性质，定义如下。 如果某个函数由复合函数表示，则该复合函数的导数可以用构成复合函数的各个函数的导数的乘积表示。 形如 $\frac{dZ}{dX} = \frac{dZ}{dt} \frac{dt}{dZ} $， 即为求导的链式法则。高数内容，不再赘述。 3.2.3 链式法则与计算图现在我们尝试将上式的链式法则的计算用计算图表示出来。如果用 “**2”节点表示平方运算的话，则计算图如图3-5所示。因为$\frac{dz}{dt} = 2t $; $\frac{dt}{dx} = 1 $ ; 所以$\frac{dz}{dx} = 2(x+y) $ 3.3 反向传播3.3.1 加法的反向传播加法反向传播将从上游传过来的导数（本例中是 ）乘以 1，然 后传向下游。也就是说，因为加法节点的反向传播只乘以1，所以输入的值 会原封不动地流向下一个节点。 3.3.2 乘法的反向传播乘法的反向传播会将上游的值乘以正向传播时的输入信号的“翻转值” 后传递给下游。翻转值表示一种翻转关系，如图5-12所示，正向传播时信号 是x的话，反向传播时则是y；正向传播时信号是y的话，反向传播时则是x。 练习结合加法和乘法，以苹果为例，尝试填入这些空格 3.4 激活函数层的反向传播实现3.4.1 ReLU 层激活函数ReLU的导数为如果正向传播时的输入x大于0，则反向传播会将上游的 值原封不动地传给下游。反过来，如果正向传播时的x小于等于0，则反向传播中传给下游的信号将停在此处所以在开始时提到的ReLU层的mask变量，是用来存储正向传播输入是否为0的变量，它是由True/False构成的NumPy数组，它会把正向传播时的输入x的元素中小于等于0的地方保存为True，其他地方（大于0的元素）保存为False。在反向传播中尤其重要。计算图表示即为 3.4.2 Sigmoid层步骤1“/”节点表示 ，它的导数可以解析性地表示为下式。$ \frac{dy}{dx} = - \frac{1}{x^2} = - y^2 $反向传播时，会将上游的值乘以$−y^2$（正向传播的输出的平方乘以−1后的值）后，再传给下游。 步骤2 “+”节点将上游的值原封不动地传给下游。 步骤3“exp”节点表示y = exp(x)，它的导数由下式表示。$ \frac{dy}{dx} = exp(x) $计算图中，上游的值乘以正向传播时的输出（这个例子中是exp(−x)）后， 再传给下游。 步骤4“×”节点将正向传播时的值翻转后做乘法运算。因此，这里要乘以−1。 最终结果为 这里要注意， 这个值只根据正向传播时的输入x和输出y就可以算出来,所以sigmoid的计算图可以简化为sigmoid节点，简洁版的计算图可以省略反向传播中的计算过程，因此计算效率更高。此外， 通过对节点进行集约化，可以不用在意Sigmoid层中琐碎的细节，而只需要专注它的输入和输出，这一点也很重要。 3.5 Affine/Softmax层的实现3.5.1 Affine层神经网络的正向传播中，为了计算加权信号的总和，使用了矩阵的乘积运算 12345AffineX = np.random.rand(2) # 输入W = np.random.rand(2，3) # 权重参数B = np.random.rand(3) # 偏置Y = np.dot(X, W) + B # 得到相乘结果 神经网络的正向传播中进行的矩阵的乘积运算在几何学领域被称为“仿 射变换” A。因此，这里将进行仿射变换的处理实现为“Affine层”。 现在将它用计算图表示出来，要注意X、W、B是矩阵（多维数组）。 之前我们见到的计算图中各个节点间流动的是标量，而这个例子中各个节点间传播的是矩阵。现在我们来考虑图 3-14 的计算图的反向传播。以矩阵为对象的反向传播，通过数学推导可得到下式$$ \frac{dL}{dX} = \frac{dL}{dY} * W^T $$$$ \frac{dL}{dW} = X^T * \frac{dL}{dY} $$表示为计算图即为：其中值得注意的是,X与$\frac{dL}{dX}$形状相同，W与$\frac{dL}{dW}$形状相同,从下式也容易看出 3.5.2 批版本的Affine层前面介绍的Affi ne层的输入X是以单个数据为对象的。现在我们考虑N 个数据一起进行正向传播的情况，也就是批版本的Affine层。先来看计算图与刚刚不同的是，现在输入X的形状是(N,2)。之后就和前面一样，在计算图上进行单纯的矩阵计算。加上偏置时，需要特别注意。正向传播时，偏置被加到X·W的各个数据上。比如，N = 2（数据为2个）时，偏置会被分别加到这2个数据（各自 的计算结果）上。因此， 反向传播时，各个数据的反向传播的值需要汇总为偏置的元素。 12345678&gt;&gt;&gt; dY = np.array([[1, 2, 3,], [4, 5, 6]]) &gt;&gt;&gt; dY array([[1, 2, 3], [4, 5, 6]]) &gt;&gt;&gt; &gt;&gt;&gt; dB = np.sum(dY, axis=0) &gt;&gt;&gt; dB array([5, 7, 9]) 这个例子中，假定数据有2个（N = 2）。偏置的反向传播会对这2个数据的导数按元素进行求和。因此，这里使用了np.sum()对第0轴（以数据为单位的轴，axis=0）方向上的元素进行求和。 3.5.3 Softmax-with-Loss 层上次我们提到过，softmax函数会将输入值正规化之后再输出。比如手写数字识别时，Softmax层的输出如下所示。 神经网络中进行的处理有推理（inference）和学习两个阶段。神经网络的推理通常不使用Softmax层。比如，用上图的网络进行推理时， 会将最后一个Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（Softmax层前面的Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要Softmax层。 不过，神经网络的学习阶段则需要Softmax层。 来看softmax的计算图，导出过程比较复杂，这里只给出最终结果 不感兴趣的话可以看简化版本 Softmax层的反向传播得到了 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。由于$（y_1,y_2,y_3）$是 Softmax层的输出，$（ t_1,t_2,t_3）$是监督数据，所以$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$是 Softmax层的输出和教师标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层，这是神经网络学习中的重要性质。神经网络学习的目的就是通过调整权重参数，使神经网络的输出（Softmax 的输出）接近教师标签。因此，必须将神经网络的输出与教师标签的误差高效地传递给前面的层。刚刚的$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$正是 Softmax层的输出与教师标签的差，直截了当地表示了当前神经网络的输出与教师标签的误差。 使用交叉熵误差作为softmax函数的损失函数后，反向传播得到 $（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样 “漂亮”的结果。实际上，这样“漂亮” 的结果并不是偶然的，而是为了得到这样的结果，特意设计了交叉熵误差函数。回归问题中输出层使用“恒等函数”，损失函数使用 “平方和误差”，也是出于同样的理由。也就是说，使用“平 方和误差”作为“恒等函数”的损失函数，反向传播才能得到$（y_1 −t_1,y_2 −t_2,y_3 −t_3）$这样“漂亮”的结果。 四、神经网络学习全貌前提神经网络中有合适的权重和偏置，调整权重和偏置以便拟合训练数据的过程称为学习神经网络的学习分为下面4个步骤。步骤1（mini-batch）从训练数据中随机选择一部分数据。步骤2（计算梯度）计算损失函数关于各个权重参数的梯度。步骤3（更新参数）将权重参数沿梯度方向进行微小的更新。步骤4（重复）重复步骤1、步骤2、步骤3。这次介绍的误差反向传播法会在步骤2中出现。上一次中，我们利用数值微分求得了这个梯度。数值微分虽然实现简单，但是计算要耗费较多的时间，而误差反向传播法可以快速高效地计算梯度。 还有一篇CNN噢，欢迎持续关注 :-D]]></content>
      <categories>
        <category>neural network</category>
      </categories>
      <tags>
        <tag>neural network</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fdesirelife6.github.io%2F2019%2F08%2F30%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[关于作者]]></title>
    <url>%2Fdesirelife6.github.io%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[我是谁我是一枚爱吃饭爱睡觉的可爱程序猿博客干嘛用我想干嘛干嘛鸭嘻嘻嘻其实可以来github给我star ： https://github.com/Desirelife6]]></content>
  </entry>
  <entry>
    <title><![CDATA[categories]]></title>
    <url>%2Fdesirelife6.github.io%2Fcategories%2Findex.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Fdesirelife6.github.io%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
